// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PrecomputedParametricShape.proto

#ifndef PROTOBUF_PrecomputedParametricShape_2eproto__INCLUDED
#define PROTOBUF_PrecomputedParametricShape_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace OptCAD {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_PrecomputedParametricShape_2eproto();
void protobuf_InitDefaults_PrecomputedParametricShape_2eproto();
void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

class AdaptiveGridCell;
class AdaptiveGridInterNode;
class AdaptiveGridLeaf;
class BasisFunction;
class BoundaryCondition;
class BoundaryConditionValue;
class BoundaryControl;
class ControlLoop;
class ControlPoints;
class CubicBSpline;
class FunctionTestShapeInfo;
class HomeomorphicSample;
class LinearBSpline;
class Link;
class PrecomputedParametricShape;
class PrecomputedPhysics;
class PrecomputedSample;
class ReferencePoint;
class ShapeInfo;
class TetMesh;
class Vector3d;
class Vector4i;

enum BoundaryType {
  FIXED_BOUNDARY = 0,
  BOUNDARY_FORCE = 1,
  BOUNDARY_HEAT = 2
};
bool BoundaryType_IsValid(int value);
const BoundaryType BoundaryType_MIN = FIXED_BOUNDARY;
const BoundaryType BoundaryType_MAX = BOUNDARY_HEAT;
const int BoundaryType_ARRAYSIZE = BoundaryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BoundaryType_descriptor();
inline const ::std::string& BoundaryType_Name(BoundaryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BoundaryType_descriptor(), value);
}
inline bool BoundaryType_Parse(
    const ::std::string& name, BoundaryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BoundaryType>(
    BoundaryType_descriptor(), name, value);
}
// ===================================================================

class PrecomputedParametricShape : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.PrecomputedParametricShape) */ {
 public:
  PrecomputedParametricShape();
  virtual ~PrecomputedParametricShape();

  PrecomputedParametricShape(const PrecomputedParametricShape& from);

  inline PrecomputedParametricShape& operator=(const PrecomputedParametricShape& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrecomputedParametricShape& default_instance();

  static const PrecomputedParametricShape* internal_default_instance();

  void Swap(PrecomputedParametricShape* other);

  // implements Message ----------------------------------------------

  inline PrecomputedParametricShape* New() const { return New(NULL); }

  PrecomputedParametricShape* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrecomputedParametricShape& from);
  void MergeFrom(const PrecomputedParametricShape& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrecomputedParametricShape* other);
  void UnsafeMergeFrom(const PrecomputedParametricShape& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OptCAD.proto.AdaptiveGridCell root = 1;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 1;
  const ::OptCAD::proto::AdaptiveGridCell& root() const;
  ::OptCAD::proto::AdaptiveGridCell* mutable_root();
  ::OptCAD::proto::AdaptiveGridCell* release_root();
  void set_allocated_root(::OptCAD::proto::AdaptiveGridCell* root);

  // repeated .OptCAD.proto.PrecomputedSample samples = 2;
  int samples_size() const;
  void clear_samples();
  static const int kSamplesFieldNumber = 2;
  const ::OptCAD::proto::PrecomputedSample& samples(int index) const;
  ::OptCAD::proto::PrecomputedSample* mutable_samples(int index);
  ::OptCAD::proto::PrecomputedSample* add_samples();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedSample >*
      mutable_samples();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedSample >&
      samples() const;

  // optional int32 bootstrapNSamples = 3;
  bool has_bootstrapnsamples() const;
  void clear_bootstrapnsamples();
  static const int kBootstrapNSamplesFieldNumber = 3;
  ::google::protobuf::int32 bootstrapnsamples() const;
  void set_bootstrapnsamples(::google::protobuf::int32 value);

  // repeated .OptCAD.proto.AdaptiveGridCell borderCells = 4;
  int bordercells_size() const;
  void clear_bordercells();
  static const int kBorderCellsFieldNumber = 4;
  const ::OptCAD::proto::AdaptiveGridCell& bordercells(int index) const;
  ::OptCAD::proto::AdaptiveGridCell* mutable_bordercells(int index);
  ::OptCAD::proto::AdaptiveGridCell* add_bordercells();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::AdaptiveGridCell >*
      mutable_bordercells();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::AdaptiveGridCell >&
      bordercells() const;

  // repeated double range = 5;
  int range_size() const;
  void clear_range();
  static const int kRangeFieldNumber = 5;
  double range(int index) const;
  void set_range(int index, double value);
  void add_range(double value);
  const ::google::protobuf::RepeatedField< double >&
      range() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_range();

  // @@protoc_insertion_point(class_scope:OptCAD.proto.PrecomputedParametricShape)
 private:
  inline void set_has_root();
  inline void clear_has_root();
  inline void set_has_bootstrapnsamples();
  inline void clear_has_bootstrapnsamples();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedSample > samples_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::AdaptiveGridCell > bordercells_;
  ::google::protobuf::RepeatedField< double > range_;
  ::OptCAD::proto::AdaptiveGridCell* root_;
  ::google::protobuf::int32 bootstrapnsamples_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PrecomputedParametricShape> PrecomputedParametricShape_default_instance_;

// -------------------------------------------------------------------

class PrecomputedSample : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.PrecomputedSample) */ {
 public:
  PrecomputedSample();
  virtual ~PrecomputedSample();

  PrecomputedSample(const PrecomputedSample& from);

  inline PrecomputedSample& operator=(const PrecomputedSample& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrecomputedSample& default_instance();

  static const PrecomputedSample* internal_default_instance();

  void Swap(PrecomputedSample* other);

  // implements Message ----------------------------------------------

  inline PrecomputedSample* New() const { return New(NULL); }

  PrecomputedSample* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrecomputedSample& from);
  void MergeFrom(const PrecomputedSample& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrecomputedSample* other);
  void UnsafeMergeFrom(const PrecomputedSample& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // repeated double center = 2;
  int center_size() const;
  void clear_center();
  static const int kCenterFieldNumber = 2;
  double center(int index) const;
  void set_center(int index, double value);
  void add_center(double value);
  const ::google::protobuf::RepeatedField< double >&
      center() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_center();

  // optional .OptCAD.proto.ShapeInfo shapeInfo = 3;
  bool has_shapeinfo() const;
  void clear_shapeinfo();
  static const int kShapeInfoFieldNumber = 3;
  const ::OptCAD::proto::ShapeInfo& shapeinfo() const;
  ::OptCAD::proto::ShapeInfo* mutable_shapeinfo();
  ::OptCAD::proto::ShapeInfo* release_shapeinfo();
  void set_allocated_shapeinfo(::OptCAD::proto::ShapeInfo* shapeinfo);

  // repeated .OptCAD.proto.BasisFunction basisFuntions = 4;
  int basisfuntions_size() const;
  void clear_basisfuntions();
  static const int kBasisFuntionsFieldNumber = 4;
  const ::OptCAD::proto::BasisFunction& basisfuntions(int index) const;
  ::OptCAD::proto::BasisFunction* mutable_basisfuntions(int index);
  ::OptCAD::proto::BasisFunction* add_basisfuntions();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BasisFunction >*
      mutable_basisfuntions();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BasisFunction >&
      basisfuntions() const;

  // @@protoc_insertion_point(class_scope:OptCAD.proto.PrecomputedSample)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_shapeinfo();
  inline void clear_has_shapeinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > center_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BasisFunction > basisfuntions_;
  ::OptCAD::proto::ShapeInfo* shapeinfo_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PrecomputedSample> PrecomputedSample_default_instance_;

// -------------------------------------------------------------------

class FunctionTestShapeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.FunctionTestShapeInfo) */ {
 public:
  FunctionTestShapeInfo();
  virtual ~FunctionTestShapeInfo();

  FunctionTestShapeInfo(const FunctionTestShapeInfo& from);

  inline FunctionTestShapeInfo& operator=(const FunctionTestShapeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FunctionTestShapeInfo& default_instance();

  static const FunctionTestShapeInfo* internal_default_instance();

  void Swap(FunctionTestShapeInfo* other);

  // implements Message ----------------------------------------------

  inline FunctionTestShapeInfo* New() const { return New(NULL); }

  FunctionTestShapeInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FunctionTestShapeInfo& from);
  void MergeFrom(const FunctionTestShapeInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FunctionTestShapeInfo* other);
  void UnsafeMergeFrom(const FunctionTestShapeInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double val = 1;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 1;
  double val() const;
  void set_val(double value);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.FunctionTestShapeInfo)
 private:
  inline void set_has_val();
  inline void clear_has_val();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double val_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<FunctionTestShapeInfo> FunctionTestShapeInfo_default_instance_;

// -------------------------------------------------------------------

class Vector4i : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.Vector4i) */ {
 public:
  Vector4i();
  virtual ~Vector4i();

  Vector4i(const Vector4i& from);

  inline Vector4i& operator=(const Vector4i& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector4i& default_instance();

  static const Vector4i* internal_default_instance();

  void Swap(Vector4i* other);

  // implements Message ----------------------------------------------

  inline Vector4i* New() const { return New(NULL); }

  Vector4i* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector4i& from);
  void MergeFrom(const Vector4i& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector4i* other);
  void UnsafeMergeFrom(const Vector4i& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // optional int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // optional int32 z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int32 z() const;
  void set_z(::google::protobuf::int32 value);

  // optional int32 w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  ::google::protobuf::int32 w() const;
  void set_w(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.Vector4i)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 z_;
  ::google::protobuf::int32 w_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Vector4i> Vector4i_default_instance_;

// -------------------------------------------------------------------

class Vector3d : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.Vector3d) */ {
 public:
  Vector3d();
  virtual ~Vector3d();

  Vector3d(const Vector3d& from);

  inline Vector3d& operator=(const Vector3d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3d& default_instance();

  static const Vector3d* internal_default_instance();

  void Swap(Vector3d* other);

  // implements Message ----------------------------------------------

  inline Vector3d* New() const { return New(NULL); }

  Vector3d* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3d& from);
  void MergeFrom(const Vector3d& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector3d* other);
  void UnsafeMergeFrom(const Vector3d& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // optional double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // optional double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.Vector3d)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double x_;
  double y_;
  double z_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Vector3d> Vector3d_default_instance_;

// -------------------------------------------------------------------

class BoundaryConditionValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.BoundaryConditionValue) */ {
 public:
  BoundaryConditionValue();
  virtual ~BoundaryConditionValue();

  BoundaryConditionValue(const BoundaryConditionValue& from);

  inline BoundaryConditionValue& operator=(const BoundaryConditionValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundaryConditionValue& default_instance();

  static const BoundaryConditionValue* internal_default_instance();

  void Swap(BoundaryConditionValue* other);

  // implements Message ----------------------------------------------

  inline BoundaryConditionValue* New() const { return New(NULL); }

  BoundaryConditionValue* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoundaryConditionValue& from);
  void MergeFrom(const BoundaryConditionValue& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoundaryConditionValue* other);
  void UnsafeMergeFrom(const BoundaryConditionValue& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OptCAD.proto.Vector3d force = 1;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 1;
  const ::OptCAD::proto::Vector3d& force() const;
  ::OptCAD::proto::Vector3d* mutable_force();
  ::OptCAD::proto::Vector3d* release_force();
  void set_allocated_force(::OptCAD::proto::Vector3d* force);

  // optional double heatValue = 2;
  bool has_heatvalue() const;
  void clear_heatvalue();
  static const int kHeatValueFieldNumber = 2;
  double heatvalue() const;
  void set_heatvalue(double value);

  // optional .OptCAD.proto.BoundaryType boundaryType = 3;
  bool has_boundarytype() const;
  void clear_boundarytype();
  static const int kBoundaryTypeFieldNumber = 3;
  ::OptCAD::proto::BoundaryType boundarytype() const;
  void set_boundarytype(::OptCAD::proto::BoundaryType value);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.BoundaryConditionValue)
 private:
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_heatvalue();
  inline void clear_has_heatvalue();
  inline void set_has_boundarytype();
  inline void clear_has_boundarytype();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::OptCAD::proto::Vector3d* force_;
  double heatvalue_;
  int boundarytype_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BoundaryConditionValue> BoundaryConditionValue_default_instance_;

// -------------------------------------------------------------------

class BoundaryCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.BoundaryCondition) */ {
 public:
  BoundaryCondition();
  virtual ~BoundaryCondition();

  BoundaryCondition(const BoundaryCondition& from);

  inline BoundaryCondition& operator=(const BoundaryCondition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundaryCondition& default_instance();

  static const BoundaryCondition* internal_default_instance();

  void Swap(BoundaryCondition* other);

  // implements Message ----------------------------------------------

  inline BoundaryCondition* New() const { return New(NULL); }

  BoundaryCondition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoundaryCondition& from);
  void MergeFrom(const BoundaryCondition& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoundaryCondition* other);
  void UnsafeMergeFrom(const BoundaryCondition& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool isFixed = 1;
  bool has_isfixed() const;
  void clear_isfixed();
  static const int kIsFixedFieldNumber = 1;
  bool isfixed() const;
  void set_isfixed(bool value);

  // optional .OptCAD.proto.Vector3d force = 2;
  bool has_force() const;
  void clear_force();
  static const int kForceFieldNumber = 2;
  const ::OptCAD::proto::Vector3d& force() const;
  ::OptCAD::proto::Vector3d* mutable_force();
  ::OptCAD::proto::Vector3d* release_force();
  void set_allocated_force(::OptCAD::proto::Vector3d* force);

  // repeated int32 vertices = 3;
  int vertices_size() const;
  void clear_vertices();
  static const int kVerticesFieldNumber = 3;
  ::google::protobuf::int32 vertices(int index) const;
  void set_vertices(int index, ::google::protobuf::int32 value);
  void add_vertices(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      vertices() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_vertices();

  // optional .OptCAD.proto.BoundaryConditionValue value = 4;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  const ::OptCAD::proto::BoundaryConditionValue& value() const;
  ::OptCAD::proto::BoundaryConditionValue* mutable_value();
  ::OptCAD::proto::BoundaryConditionValue* release_value();
  void set_allocated_value(::OptCAD::proto::BoundaryConditionValue* value);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.BoundaryCondition)
 private:
  inline void set_has_isfixed();
  inline void clear_has_isfixed();
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > vertices_;
  ::OptCAD::proto::Vector3d* force_;
  ::OptCAD::proto::BoundaryConditionValue* value_;
  bool isfixed_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BoundaryCondition> BoundaryCondition_default_instance_;

// -------------------------------------------------------------------

class PrecomputedPhysics : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.PrecomputedPhysics) */ {
 public:
  PrecomputedPhysics();
  virtual ~PrecomputedPhysics();

  PrecomputedPhysics(const PrecomputedPhysics& from);

  inline PrecomputedPhysics& operator=(const PrecomputedPhysics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrecomputedPhysics& default_instance();

  static const PrecomputedPhysics* internal_default_instance();

  void Swap(PrecomputedPhysics* other);

  // implements Message ----------------------------------------------

  inline PrecomputedPhysics* New() const { return New(NULL); }

  PrecomputedPhysics* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrecomputedPhysics& from);
  void MergeFrom(const PrecomputedPhysics& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrecomputedPhysics* other);
  void UnsafeMergeFrom(const PrecomputedPhysics& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // repeated double values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::google::protobuf::RepeatedField< double >&
      values() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_values();

  // @@protoc_insertion_point(class_scope:OptCAD.proto.PrecomputedPhysics)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > values_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<PrecomputedPhysics> PrecomputedPhysics_default_instance_;

// -------------------------------------------------------------------

class ReferencePoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.ReferencePoint) */ {
 public:
  ReferencePoint();
  virtual ~ReferencePoint();

  ReferencePoint(const ReferencePoint& from);

  inline ReferencePoint& operator=(const ReferencePoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferencePoint& default_instance();

  static const ReferencePoint* internal_default_instance();

  void Swap(ReferencePoint* other);

  // implements Message ----------------------------------------------

  inline ReferencePoint* New() const { return New(NULL); }

  ReferencePoint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReferencePoint& from);
  void MergeFrom(const ReferencePoint& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReferencePoint* other);
  void UnsafeMergeFrom(const ReferencePoint& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional .OptCAD.proto.Vector3d pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::OptCAD::proto::Vector3d& pos() const;
  ::OptCAD::proto::Vector3d* mutable_pos();
  ::OptCAD::proto::Vector3d* release_pos();
  void set_allocated_pos(::OptCAD::proto::Vector3d* pos);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.ReferencePoint)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::OptCAD::proto::Vector3d* pos_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ReferencePoint> ReferencePoint_default_instance_;

// -------------------------------------------------------------------

class Link : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.Link) */ {
 public:
  Link();
  virtual ~Link();

  Link(const Link& from);

  inline Link& operator=(const Link& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Link& default_instance();

  static const Link* internal_default_instance();

  void Swap(Link* other);

  // implements Message ----------------------------------------------

  inline Link* New() const { return New(NULL); }

  Link* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Link& from);
  void MergeFrom(const Link& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Link* other);
  void UnsafeMergeFrom(const Link& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string first = 1;
  bool has_first() const;
  void clear_first();
  static const int kFirstFieldNumber = 1;
  const ::std::string& first() const;
  void set_first(const ::std::string& value);
  void set_first(const char* value);
  void set_first(const char* value, size_t size);
  ::std::string* mutable_first();
  ::std::string* release_first();
  void set_allocated_first(::std::string* first);

  // optional string second = 2;
  bool has_second() const;
  void clear_second();
  static const int kSecondFieldNumber = 2;
  const ::std::string& second() const;
  void set_second(const ::std::string& value);
  void set_second(const char* value);
  void set_second(const char* value, size_t size);
  ::std::string* mutable_second();
  ::std::string* release_second();
  void set_allocated_second(::std::string* second);

  // repeated .OptCAD.proto.Vector3d midPoints = 3;
  int midpoints_size() const;
  void clear_midpoints();
  static const int kMidPointsFieldNumber = 3;
  const ::OptCAD::proto::Vector3d& midpoints(int index) const;
  ::OptCAD::proto::Vector3d* mutable_midpoints(int index);
  ::OptCAD::proto::Vector3d* add_midpoints();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d >*
      mutable_midpoints();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d >&
      midpoints() const;

  // @@protoc_insertion_point(class_scope:OptCAD.proto.Link)
 private:
  inline void set_has_first();
  inline void clear_has_first();
  inline void set_has_second();
  inline void clear_has_second();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d > midpoints_;
  ::google::protobuf::internal::ArenaStringPtr first_;
  ::google::protobuf::internal::ArenaStringPtr second_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Link> Link_default_instance_;

// -------------------------------------------------------------------

class ControlLoop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.ControlLoop) */ {
 public:
  ControlLoop();
  virtual ~ControlLoop();

  ControlLoop(const ControlLoop& from);

  inline ControlLoop& operator=(const ControlLoop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlLoop& default_instance();

  static const ControlLoop* internal_default_instance();

  void Swap(ControlLoop* other);

  // implements Message ----------------------------------------------

  inline ControlLoop* New() const { return New(NULL); }

  ControlLoop* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlLoop& from);
  void MergeFrom(const ControlLoop& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ControlLoop* other);
  void UnsafeMergeFrom(const ControlLoop& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string loop = 1;
  int loop_size() const;
  void clear_loop();
  static const int kLoopFieldNumber = 1;
  const ::std::string& loop(int index) const;
  ::std::string* mutable_loop(int index);
  void set_loop(int index, const ::std::string& value);
  void set_loop(int index, const char* value);
  void set_loop(int index, const char* value, size_t size);
  ::std::string* add_loop();
  void add_loop(const ::std::string& value);
  void add_loop(const char* value);
  void add_loop(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& loop() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_loop();

  // @@protoc_insertion_point(class_scope:OptCAD.proto.ControlLoop)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> loop_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ControlLoop> ControlLoop_default_instance_;

// -------------------------------------------------------------------

class BoundaryControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.BoundaryControl) */ {
 public:
  BoundaryControl();
  virtual ~BoundaryControl();

  BoundaryControl(const BoundaryControl& from);

  inline BoundaryControl& operator=(const BoundaryControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BoundaryControl& default_instance();

  static const BoundaryControl* internal_default_instance();

  void Swap(BoundaryControl* other);

  // implements Message ----------------------------------------------

  inline BoundaryControl* New() const { return New(NULL); }

  BoundaryControl* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BoundaryControl& from);
  void MergeFrom(const BoundaryControl& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BoundaryControl* other);
  void UnsafeMergeFrom(const BoundaryControl& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OptCAD.proto.ControlLoop controlLoops = 1;
  int controlloops_size() const;
  void clear_controlloops();
  static const int kControlLoopsFieldNumber = 1;
  const ::OptCAD::proto::ControlLoop& controlloops(int index) const;
  ::OptCAD::proto::ControlLoop* mutable_controlloops(int index);
  ::OptCAD::proto::ControlLoop* add_controlloops();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ControlLoop >*
      mutable_controlloops();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ControlLoop >&
      controlloops() const;

  // optional .OptCAD.proto.BoundaryConditionValue value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::OptCAD::proto::BoundaryConditionValue& value() const;
  ::OptCAD::proto::BoundaryConditionValue* mutable_value();
  ::OptCAD::proto::BoundaryConditionValue* release_value();
  void set_allocated_value(::OptCAD::proto::BoundaryConditionValue* value);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.BoundaryControl)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ControlLoop > controlloops_;
  ::OptCAD::proto::BoundaryConditionValue* value_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BoundaryControl> BoundaryControl_default_instance_;

// -------------------------------------------------------------------

class ControlPoints : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.ControlPoints) */ {
 public:
  ControlPoints();
  virtual ~ControlPoints();

  ControlPoints(const ControlPoints& from);

  inline ControlPoints& operator=(const ControlPoints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControlPoints& default_instance();

  static const ControlPoints* internal_default_instance();

  void Swap(ControlPoints* other);

  // implements Message ----------------------------------------------

  inline ControlPoints* New() const { return New(NULL); }

  ControlPoints* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControlPoints& from);
  void MergeFrom(const ControlPoints& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ControlPoints* other);
  void UnsafeMergeFrom(const ControlPoints& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OptCAD.proto.ReferencePoint point = 1;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::OptCAD::proto::ReferencePoint& point(int index) const;
  ::OptCAD::proto::ReferencePoint* mutable_point(int index);
  ::OptCAD::proto::ReferencePoint* add_point();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ReferencePoint >*
      mutable_point();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ReferencePoint >&
      point() const;

  // repeated .OptCAD.proto.Link links = 2;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 2;
  const ::OptCAD::proto::Link& links(int index) const;
  ::OptCAD::proto::Link* mutable_links(int index);
  ::OptCAD::proto::Link* add_links();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Link >*
      mutable_links();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Link >&
      links() const;

  // repeated .OptCAD.proto.BoundaryControl boundaryControls = 3;
  int boundarycontrols_size() const;
  void clear_boundarycontrols();
  static const int kBoundaryControlsFieldNumber = 3;
  const ::OptCAD::proto::BoundaryControl& boundarycontrols(int index) const;
  ::OptCAD::proto::BoundaryControl* mutable_boundarycontrols(int index);
  ::OptCAD::proto::BoundaryControl* add_boundarycontrols();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryControl >*
      mutable_boundarycontrols();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryControl >&
      boundarycontrols() const;

  // @@protoc_insertion_point(class_scope:OptCAD.proto.ControlPoints)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ReferencePoint > point_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Link > links_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryControl > boundarycontrols_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ControlPoints> ControlPoints_default_instance_;

// -------------------------------------------------------------------

class TetMesh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.TetMesh) */ {
 public:
  TetMesh();
  virtual ~TetMesh();

  TetMesh(const TetMesh& from);

  inline TetMesh& operator=(const TetMesh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TetMesh& default_instance();

  static const TetMesh* internal_default_instance();

  void Swap(TetMesh* other);

  // implements Message ----------------------------------------------

  inline TetMesh* New() const { return New(NULL); }

  TetMesh* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TetMesh& from);
  void MergeFrom(const TetMesh& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TetMesh* other);
  void UnsafeMergeFrom(const TetMesh& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .OptCAD.proto.Vector3d vertices = 1;
  int vertices_size() const;
  void clear_vertices();
  static const int kVerticesFieldNumber = 1;
  const ::OptCAD::proto::Vector3d& vertices(int index) const;
  ::OptCAD::proto::Vector3d* mutable_vertices(int index);
  ::OptCAD::proto::Vector3d* add_vertices();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d >*
      mutable_vertices();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d >&
      vertices() const;

  // repeated .OptCAD.proto.Vector4i tets = 2;
  int tets_size() const;
  void clear_tets();
  static const int kTetsFieldNumber = 2;
  const ::OptCAD::proto::Vector4i& tets(int index) const;
  ::OptCAD::proto::Vector4i* mutable_tets(int index);
  ::OptCAD::proto::Vector4i* add_tets();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector4i >*
      mutable_tets();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector4i >&
      tets() const;

  // repeated .OptCAD.proto.BoundaryCondition boundaryConditions = 3;
  int boundaryconditions_size() const;
  void clear_boundaryconditions();
  static const int kBoundaryConditionsFieldNumber = 3;
  const ::OptCAD::proto::BoundaryCondition& boundaryconditions(int index) const;
  ::OptCAD::proto::BoundaryCondition* mutable_boundaryconditions(int index);
  ::OptCAD::proto::BoundaryCondition* add_boundaryconditions();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryCondition >*
      mutable_boundaryconditions();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryCondition >&
      boundaryconditions() const;

  // repeated .OptCAD.proto.PrecomputedPhysics precomputedPhysics = 4;
  int precomputedphysics_size() const;
  void clear_precomputedphysics();
  static const int kPrecomputedPhysicsFieldNumber = 4;
  const ::OptCAD::proto::PrecomputedPhysics& precomputedphysics(int index) const;
  ::OptCAD::proto::PrecomputedPhysics* mutable_precomputedphysics(int index);
  ::OptCAD::proto::PrecomputedPhysics* add_precomputedphysics();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedPhysics >*
      mutable_precomputedphysics();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedPhysics >&
      precomputedphysics() const;

  // optional string filename = 5;
  bool has_filename() const;
  void clear_filename();
  static const int kFilenameFieldNumber = 5;
  const ::std::string& filename() const;
  void set_filename(const ::std::string& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  ::std::string* mutable_filename();
  ::std::string* release_filename();
  void set_allocated_filename(::std::string* filename);

  // optional .OptCAD.proto.ControlPoints controlPoints = 6;
  bool has_controlpoints() const;
  void clear_controlpoints();
  static const int kControlPointsFieldNumber = 6;
  const ::OptCAD::proto::ControlPoints& controlpoints() const;
  ::OptCAD::proto::ControlPoints* mutable_controlpoints();
  ::OptCAD::proto::ControlPoints* release_controlpoints();
  void set_allocated_controlpoints(::OptCAD::proto::ControlPoints* controlpoints);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.TetMesh)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_controlpoints();
  inline void clear_has_controlpoints();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d > vertices_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector4i > tets_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryCondition > boundaryconditions_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedPhysics > precomputedphysics_;
  ::google::protobuf::internal::ArenaStringPtr filename_;
  ::OptCAD::proto::ControlPoints* controlpoints_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TetMesh> TetMesh_default_instance_;

// -------------------------------------------------------------------

class ShapeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.ShapeInfo) */ {
 public:
  ShapeInfo();
  virtual ~ShapeInfo();

  ShapeInfo(const ShapeInfo& from);

  inline ShapeInfo& operator=(const ShapeInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShapeInfo& default_instance();

  static const ShapeInfo* internal_default_instance();

  void Swap(ShapeInfo* other);

  // implements Message ----------------------------------------------

  inline ShapeInfo* New() const { return New(NULL); }

  ShapeInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShapeInfo& from);
  void MergeFrom(const ShapeInfo& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShapeInfo* other);
  void UnsafeMergeFrom(const ShapeInfo& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OptCAD.proto.FunctionTestShapeInfo functionShapeInfo = 1;
  bool has_functionshapeinfo() const;
  void clear_functionshapeinfo();
  static const int kFunctionShapeInfoFieldNumber = 1;
  const ::OptCAD::proto::FunctionTestShapeInfo& functionshapeinfo() const;
  ::OptCAD::proto::FunctionTestShapeInfo* mutable_functionshapeinfo();
  ::OptCAD::proto::FunctionTestShapeInfo* release_functionshapeinfo();
  void set_allocated_functionshapeinfo(::OptCAD::proto::FunctionTestShapeInfo* functionshapeinfo);

  // optional .OptCAD.proto.TetMesh tetMesh = 2;
  bool has_tetmesh() const;
  void clear_tetmesh();
  static const int kTetMeshFieldNumber = 2;
  const ::OptCAD::proto::TetMesh& tetmesh() const;
  ::OptCAD::proto::TetMesh* mutable_tetmesh();
  ::OptCAD::proto::TetMesh* release_tetmesh();
  void set_allocated_tetmesh(::OptCAD::proto::TetMesh* tetmesh);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.ShapeInfo)
 private:
  inline void set_has_functionshapeinfo();
  inline void clear_has_functionshapeinfo();
  inline void set_has_tetmesh();
  inline void clear_has_tetmesh();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::OptCAD::proto::FunctionTestShapeInfo* functionshapeinfo_;
  ::OptCAD::proto::TetMesh* tetmesh_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<ShapeInfo> ShapeInfo_default_instance_;

// -------------------------------------------------------------------

class BasisFunction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.BasisFunction) */ {
 public:
  BasisFunction();
  virtual ~BasisFunction();

  BasisFunction(const BasisFunction& from);

  inline BasisFunction& operator=(const BasisFunction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BasisFunction& default_instance();

  static const BasisFunction* internal_default_instance();

  void Swap(BasisFunction* other);

  // implements Message ----------------------------------------------

  inline BasisFunction* New() const { return New(NULL); }

  BasisFunction* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BasisFunction& from);
  void MergeFrom(const BasisFunction& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BasisFunction* other);
  void UnsafeMergeFrom(const BasisFunction& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OptCAD.proto.LinearBSpline linearBspline = 1;
  bool has_linearbspline() const;
  void clear_linearbspline();
  static const int kLinearBsplineFieldNumber = 1;
  const ::OptCAD::proto::LinearBSpline& linearbspline() const;
  ::OptCAD::proto::LinearBSpline* mutable_linearbspline();
  ::OptCAD::proto::LinearBSpline* release_linearbspline();
  void set_allocated_linearbspline(::OptCAD::proto::LinearBSpline* linearbspline);

  // optional .OptCAD.proto.CubicBSpline cubicBspline = 2;
  bool has_cubicbspline() const;
  void clear_cubicbspline();
  static const int kCubicBsplineFieldNumber = 2;
  const ::OptCAD::proto::CubicBSpline& cubicbspline() const;
  ::OptCAD::proto::CubicBSpline* mutable_cubicbspline();
  ::OptCAD::proto::CubicBSpline* release_cubicbspline();
  void set_allocated_cubicbspline(::OptCAD::proto::CubicBSpline* cubicbspline);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.BasisFunction)
 private:
  inline void set_has_linearbspline();
  inline void clear_has_linearbspline();
  inline void set_has_cubicbspline();
  inline void clear_has_cubicbspline();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::OptCAD::proto::LinearBSpline* linearbspline_;
  ::OptCAD::proto::CubicBSpline* cubicbspline_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<BasisFunction> BasisFunction_default_instance_;

// -------------------------------------------------------------------

class LinearBSpline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.LinearBSpline) */ {
 public:
  LinearBSpline();
  virtual ~LinearBSpline();

  LinearBSpline(const LinearBSpline& from);

  inline LinearBSpline& operator=(const LinearBSpline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearBSpline& default_instance();

  static const LinearBSpline* internal_default_instance();

  void Swap(LinearBSpline* other);

  // implements Message ----------------------------------------------

  inline LinearBSpline* New() const { return New(NULL); }

  LinearBSpline* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinearBSpline& from);
  void MergeFrom(const LinearBSpline& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LinearBSpline* other);
  void UnsafeMergeFrom(const LinearBSpline& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double center = 1;
  int center_size() const;
  void clear_center();
  static const int kCenterFieldNumber = 1;
  double center(int index) const;
  void set_center(int index, double value);
  void add_center(double value);
  const ::google::protobuf::RepeatedField< double >&
      center() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_center();

  // repeated double support = 2;
  int support_size() const;
  void clear_support();
  static const int kSupportFieldNumber = 2;
  double support(int index) const;
  void set_support(int index, double value);
  void add_support(double value);
  const ::google::protobuf::RepeatedField< double >&
      support() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_support();

  // optional double weight = 3;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 3;
  double weight() const;
  void set_weight(double value);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.LinearBSpline)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > center_;
  ::google::protobuf::RepeatedField< double > support_;
  double weight_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<LinearBSpline> LinearBSpline_default_instance_;

// -------------------------------------------------------------------

class CubicBSpline : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.CubicBSpline) */ {
 public:
  CubicBSpline();
  virtual ~CubicBSpline();

  CubicBSpline(const CubicBSpline& from);

  inline CubicBSpline& operator=(const CubicBSpline& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CubicBSpline& default_instance();

  static const CubicBSpline* internal_default_instance();

  void Swap(CubicBSpline* other);

  // implements Message ----------------------------------------------

  inline CubicBSpline* New() const { return New(NULL); }

  CubicBSpline* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CubicBSpline& from);
  void MergeFrom(const CubicBSpline& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CubicBSpline* other);
  void UnsafeMergeFrom(const CubicBSpline& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double center = 1;
  int center_size() const;
  void clear_center();
  static const int kCenterFieldNumber = 1;
  double center(int index) const;
  void set_center(int index, double value);
  void add_center(double value);
  const ::google::protobuf::RepeatedField< double >&
      center() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_center();

  // repeated double support = 2;
  int support_size() const;
  void clear_support();
  static const int kSupportFieldNumber = 2;
  double support(int index) const;
  void set_support(int index, double value);
  void add_support(double value);
  const ::google::protobuf::RepeatedField< double >&
      support() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_support();

  // optional double weight = 3;
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 3;
  double weight() const;
  void set_weight(double value);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.CubicBSpline)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > center_;
  ::google::protobuf::RepeatedField< double > support_;
  double weight_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CubicBSpline> CubicBSpline_default_instance_;

// -------------------------------------------------------------------

class AdaptiveGridCell : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.AdaptiveGridCell) */ {
 public:
  AdaptiveGridCell();
  virtual ~AdaptiveGridCell();

  AdaptiveGridCell(const AdaptiveGridCell& from);

  inline AdaptiveGridCell& operator=(const AdaptiveGridCell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdaptiveGridCell& default_instance();

  static const AdaptiveGridCell* internal_default_instance();

  void Swap(AdaptiveGridCell* other);

  // implements Message ----------------------------------------------

  inline AdaptiveGridCell* New() const { return New(NULL); }

  AdaptiveGridCell* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdaptiveGridCell& from);
  void MergeFrom(const AdaptiveGridCell& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdaptiveGridCell* other);
  void UnsafeMergeFrom(const AdaptiveGridCell& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double ranges = 1;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 1;
  double ranges(int index) const;
  void set_ranges(int index, double value);
  void add_ranges(double value);
  const ::google::protobuf::RepeatedField< double >&
      ranges() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_ranges();

  // optional .OptCAD.proto.AdaptiveGridLeaf leaf = 2;
  bool has_leaf() const;
  void clear_leaf();
  static const int kLeafFieldNumber = 2;
  const ::OptCAD::proto::AdaptiveGridLeaf& leaf() const;
  ::OptCAD::proto::AdaptiveGridLeaf* mutable_leaf();
  ::OptCAD::proto::AdaptiveGridLeaf* release_leaf();
  void set_allocated_leaf(::OptCAD::proto::AdaptiveGridLeaf* leaf);

  // optional .OptCAD.proto.AdaptiveGridInterNode interNode = 3;
  bool has_internode() const;
  void clear_internode();
  static const int kInterNodeFieldNumber = 3;
  const ::OptCAD::proto::AdaptiveGridInterNode& internode() const;
  ::OptCAD::proto::AdaptiveGridInterNode* mutable_internode();
  ::OptCAD::proto::AdaptiveGridInterNode* release_internode();
  void set_allocated_internode(::OptCAD::proto::AdaptiveGridInterNode* internode);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.AdaptiveGridCell)
 private:
  inline void set_has_leaf();
  inline void clear_has_leaf();
  inline void set_has_internode();
  inline void clear_has_internode();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > ranges_;
  ::OptCAD::proto::AdaptiveGridLeaf* leaf_;
  ::OptCAD::proto::AdaptiveGridInterNode* internode_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AdaptiveGridCell> AdaptiveGridCell_default_instance_;

// -------------------------------------------------------------------

class AdaptiveGridLeaf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.AdaptiveGridLeaf) */ {
 public:
  AdaptiveGridLeaf();
  virtual ~AdaptiveGridLeaf();

  AdaptiveGridLeaf(const AdaptiveGridLeaf& from);

  inline AdaptiveGridLeaf& operator=(const AdaptiveGridLeaf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdaptiveGridLeaf& default_instance();

  static const AdaptiveGridLeaf* internal_default_instance();

  void Swap(AdaptiveGridLeaf* other);

  // implements Message ----------------------------------------------

  inline AdaptiveGridLeaf* New() const { return New(NULL); }

  AdaptiveGridLeaf* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdaptiveGridLeaf& from);
  void MergeFrom(const AdaptiveGridLeaf& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdaptiveGridLeaf* other);
  void UnsafeMergeFrom(const AdaptiveGridLeaf& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OptCAD.proto.ShapeInfo centerShapeInfo = 1;
  bool has_centershapeinfo() const;
  void clear_centershapeinfo();
  static const int kCenterShapeInfoFieldNumber = 1;
  const ::OptCAD::proto::ShapeInfo& centershapeinfo() const;
  ::OptCAD::proto::ShapeInfo* mutable_centershapeinfo();
  ::OptCAD::proto::ShapeInfo* release_centershapeinfo();
  void set_allocated_centershapeinfo(::OptCAD::proto::ShapeInfo* centershapeinfo);

  // repeated .OptCAD.proto.HomeomorphicSample homeomorphicSamples = 2;
  int homeomorphicsamples_size() const;
  void clear_homeomorphicsamples();
  static const int kHomeomorphicSamplesFieldNumber = 2;
  const ::OptCAD::proto::HomeomorphicSample& homeomorphicsamples(int index) const;
  ::OptCAD::proto::HomeomorphicSample* mutable_homeomorphicsamples(int index);
  ::OptCAD::proto::HomeomorphicSample* add_homeomorphicsamples();
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::HomeomorphicSample >*
      mutable_homeomorphicsamples();
  const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::HomeomorphicSample >&
      homeomorphicsamples() const;

  // @@protoc_insertion_point(class_scope:OptCAD.proto.AdaptiveGridLeaf)
 private:
  inline void set_has_centershapeinfo();
  inline void clear_has_centershapeinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::HomeomorphicSample > homeomorphicsamples_;
  ::OptCAD::proto::ShapeInfo* centershapeinfo_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AdaptiveGridLeaf> AdaptiveGridLeaf_default_instance_;

// -------------------------------------------------------------------

class HomeomorphicSample : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.HomeomorphicSample) */ {
 public:
  HomeomorphicSample();
  virtual ~HomeomorphicSample();

  HomeomorphicSample(const HomeomorphicSample& from);

  inline HomeomorphicSample& operator=(const HomeomorphicSample& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HomeomorphicSample& default_instance();

  static const HomeomorphicSample* internal_default_instance();

  void Swap(HomeomorphicSample* other);

  // implements Message ----------------------------------------------

  inline HomeomorphicSample* New() const { return New(NULL); }

  HomeomorphicSample* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HomeomorphicSample& from);
  void MergeFrom(const HomeomorphicSample& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HomeomorphicSample* other);
  void UnsafeMergeFrom(const HomeomorphicSample& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 precomputedSampleID = 1;
  bool has_precomputedsampleid() const;
  void clear_precomputedsampleid();
  static const int kPrecomputedSampleIDFieldNumber = 1;
  ::google::protobuf::int32 precomputedsampleid() const;
  void set_precomputedsampleid(::google::protobuf::int32 value);

  // optional .OptCAD.proto.ShapeInfo shapeInfo = 2;
  bool has_shapeinfo() const;
  void clear_shapeinfo();
  static const int kShapeInfoFieldNumber = 2;
  const ::OptCAD::proto::ShapeInfo& shapeinfo() const;
  ::OptCAD::proto::ShapeInfo* mutable_shapeinfo();
  ::OptCAD::proto::ShapeInfo* release_shapeinfo();
  void set_allocated_shapeinfo(::OptCAD::proto::ShapeInfo* shapeinfo);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.HomeomorphicSample)
 private:
  inline void set_has_precomputedsampleid();
  inline void clear_has_precomputedsampleid();
  inline void set_has_shapeinfo();
  inline void clear_has_shapeinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::OptCAD::proto::ShapeInfo* shapeinfo_;
  ::google::protobuf::int32 precomputedsampleid_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<HomeomorphicSample> HomeomorphicSample_default_instance_;

// -------------------------------------------------------------------

class AdaptiveGridInterNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OptCAD.proto.AdaptiveGridInterNode) */ {
 public:
  AdaptiveGridInterNode();
  virtual ~AdaptiveGridInterNode();

  AdaptiveGridInterNode(const AdaptiveGridInterNode& from);

  inline AdaptiveGridInterNode& operator=(const AdaptiveGridInterNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdaptiveGridInterNode& default_instance();

  static const AdaptiveGridInterNode* internal_default_instance();

  void Swap(AdaptiveGridInterNode* other);

  // implements Message ----------------------------------------------

  inline AdaptiveGridInterNode* New() const { return New(NULL); }

  AdaptiveGridInterNode* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdaptiveGridInterNode& from);
  void MergeFrom(const AdaptiveGridInterNode& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdaptiveGridInterNode* other);
  void UnsafeMergeFrom(const AdaptiveGridInterNode& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .OptCAD.proto.AdaptiveGridCell child1 = 1;
  bool has_child1() const;
  void clear_child1();
  static const int kChild1FieldNumber = 1;
  const ::OptCAD::proto::AdaptiveGridCell& child1() const;
  ::OptCAD::proto::AdaptiveGridCell* mutable_child1();
  ::OptCAD::proto::AdaptiveGridCell* release_child1();
  void set_allocated_child1(::OptCAD::proto::AdaptiveGridCell* child1);

  // optional .OptCAD.proto.AdaptiveGridCell child2 = 2;
  bool has_child2() const;
  void clear_child2();
  static const int kChild2FieldNumber = 2;
  const ::OptCAD::proto::AdaptiveGridCell& child2() const;
  ::OptCAD::proto::AdaptiveGridCell* mutable_child2();
  ::OptCAD::proto::AdaptiveGridCell* release_child2();
  void set_allocated_child2(::OptCAD::proto::AdaptiveGridCell* child2);

  // optional int32 splidDirection = 3;
  bool has_spliddirection() const;
  void clear_spliddirection();
  static const int kSplidDirectionFieldNumber = 3;
  ::google::protobuf::int32 spliddirection() const;
  void set_spliddirection(::google::protobuf::int32 value);

  // optional double splitVal = 4;
  bool has_splitval() const;
  void clear_splitval();
  static const int kSplitValFieldNumber = 4;
  double splitval() const;
  void set_splitval(double value);

  // @@protoc_insertion_point(class_scope:OptCAD.proto.AdaptiveGridInterNode)
 private:
  inline void set_has_child1();
  inline void clear_has_child1();
  inline void set_has_child2();
  inline void clear_has_child2();
  inline void set_has_spliddirection();
  inline void clear_has_spliddirection();
  inline void set_has_splitval();
  inline void clear_has_splitval();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::OptCAD::proto::AdaptiveGridCell* child1_;
  ::OptCAD::proto::AdaptiveGridCell* child2_;
  double splitval_;
  ::google::protobuf::int32 spliddirection_;
  friend void  protobuf_InitDefaults_PrecomputedParametricShape_2eproto_impl();
  friend void  protobuf_AddDesc_PrecomputedParametricShape_2eproto_impl();
  friend void protobuf_AssignDesc_PrecomputedParametricShape_2eproto();
  friend void protobuf_ShutdownFile_PrecomputedParametricShape_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AdaptiveGridInterNode> AdaptiveGridInterNode_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PrecomputedParametricShape

// optional .OptCAD.proto.AdaptiveGridCell root = 1;
inline bool PrecomputedParametricShape::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrecomputedParametricShape::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrecomputedParametricShape::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrecomputedParametricShape::clear_root() {
  if (root_ != NULL) root_->::OptCAD::proto::AdaptiveGridCell::Clear();
  clear_has_root();
}
inline const ::OptCAD::proto::AdaptiveGridCell& PrecomputedParametricShape::root() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedParametricShape.root)
  return root_ != NULL ? *root_
                         : *::OptCAD::proto::AdaptiveGridCell::internal_default_instance();
}
inline ::OptCAD::proto::AdaptiveGridCell* PrecomputedParametricShape::mutable_root() {
  set_has_root();
  if (root_ == NULL) {
    root_ = new ::OptCAD::proto::AdaptiveGridCell;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.PrecomputedParametricShape.root)
  return root_;
}
inline ::OptCAD::proto::AdaptiveGridCell* PrecomputedParametricShape::release_root() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.PrecomputedParametricShape.root)
  clear_has_root();
  ::OptCAD::proto::AdaptiveGridCell* temp = root_;
  root_ = NULL;
  return temp;
}
inline void PrecomputedParametricShape::set_allocated_root(::OptCAD::proto::AdaptiveGridCell* root) {
  delete root_;
  root_ = root;
  if (root) {
    set_has_root();
  } else {
    clear_has_root();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.PrecomputedParametricShape.root)
}

// repeated .OptCAD.proto.PrecomputedSample samples = 2;
inline int PrecomputedParametricShape::samples_size() const {
  return samples_.size();
}
inline void PrecomputedParametricShape::clear_samples() {
  samples_.Clear();
}
inline const ::OptCAD::proto::PrecomputedSample& PrecomputedParametricShape::samples(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedParametricShape.samples)
  return samples_.Get(index);
}
inline ::OptCAD::proto::PrecomputedSample* PrecomputedParametricShape::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.PrecomputedParametricShape.samples)
  return samples_.Mutable(index);
}
inline ::OptCAD::proto::PrecomputedSample* PrecomputedParametricShape::add_samples() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.PrecomputedParametricShape.samples)
  return samples_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedSample >*
PrecomputedParametricShape::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.PrecomputedParametricShape.samples)
  return &samples_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedSample >&
PrecomputedParametricShape::samples() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.PrecomputedParametricShape.samples)
  return samples_;
}

// optional int32 bootstrapNSamples = 3;
inline bool PrecomputedParametricShape::has_bootstrapnsamples() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrecomputedParametricShape::set_has_bootstrapnsamples() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrecomputedParametricShape::clear_has_bootstrapnsamples() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrecomputedParametricShape::clear_bootstrapnsamples() {
  bootstrapnsamples_ = 0;
  clear_has_bootstrapnsamples();
}
inline ::google::protobuf::int32 PrecomputedParametricShape::bootstrapnsamples() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedParametricShape.bootstrapNSamples)
  return bootstrapnsamples_;
}
inline void PrecomputedParametricShape::set_bootstrapnsamples(::google::protobuf::int32 value) {
  set_has_bootstrapnsamples();
  bootstrapnsamples_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.PrecomputedParametricShape.bootstrapNSamples)
}

// repeated .OptCAD.proto.AdaptiveGridCell borderCells = 4;
inline int PrecomputedParametricShape::bordercells_size() const {
  return bordercells_.size();
}
inline void PrecomputedParametricShape::clear_bordercells() {
  bordercells_.Clear();
}
inline const ::OptCAD::proto::AdaptiveGridCell& PrecomputedParametricShape::bordercells(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedParametricShape.borderCells)
  return bordercells_.Get(index);
}
inline ::OptCAD::proto::AdaptiveGridCell* PrecomputedParametricShape::mutable_bordercells(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.PrecomputedParametricShape.borderCells)
  return bordercells_.Mutable(index);
}
inline ::OptCAD::proto::AdaptiveGridCell* PrecomputedParametricShape::add_bordercells() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.PrecomputedParametricShape.borderCells)
  return bordercells_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::AdaptiveGridCell >*
PrecomputedParametricShape::mutable_bordercells() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.PrecomputedParametricShape.borderCells)
  return &bordercells_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::AdaptiveGridCell >&
PrecomputedParametricShape::bordercells() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.PrecomputedParametricShape.borderCells)
  return bordercells_;
}

// repeated double range = 5;
inline int PrecomputedParametricShape::range_size() const {
  return range_.size();
}
inline void PrecomputedParametricShape::clear_range() {
  range_.Clear();
}
inline double PrecomputedParametricShape::range(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedParametricShape.range)
  return range_.Get(index);
}
inline void PrecomputedParametricShape::set_range(int index, double value) {
  range_.Set(index, value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.PrecomputedParametricShape.range)
}
inline void PrecomputedParametricShape::add_range(double value) {
  range_.Add(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.PrecomputedParametricShape.range)
}
inline const ::google::protobuf::RepeatedField< double >&
PrecomputedParametricShape::range() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.PrecomputedParametricShape.range)
  return range_;
}
inline ::google::protobuf::RepeatedField< double >*
PrecomputedParametricShape::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.PrecomputedParametricShape.range)
  return &range_;
}

inline const PrecomputedParametricShape* PrecomputedParametricShape::internal_default_instance() {
  return &PrecomputedParametricShape_default_instance_.get();
}
// -------------------------------------------------------------------

// PrecomputedSample

// optional int32 id = 1;
inline bool PrecomputedSample::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrecomputedSample::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrecomputedSample::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrecomputedSample::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 PrecomputedSample::id() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedSample.id)
  return id_;
}
inline void PrecomputedSample::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.PrecomputedSample.id)
}

// repeated double center = 2;
inline int PrecomputedSample::center_size() const {
  return center_.size();
}
inline void PrecomputedSample::clear_center() {
  center_.Clear();
}
inline double PrecomputedSample::center(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedSample.center)
  return center_.Get(index);
}
inline void PrecomputedSample::set_center(int index, double value) {
  center_.Set(index, value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.PrecomputedSample.center)
}
inline void PrecomputedSample::add_center(double value) {
  center_.Add(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.PrecomputedSample.center)
}
inline const ::google::protobuf::RepeatedField< double >&
PrecomputedSample::center() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.PrecomputedSample.center)
  return center_;
}
inline ::google::protobuf::RepeatedField< double >*
PrecomputedSample::mutable_center() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.PrecomputedSample.center)
  return &center_;
}

// optional .OptCAD.proto.ShapeInfo shapeInfo = 3;
inline bool PrecomputedSample::has_shapeinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PrecomputedSample::set_has_shapeinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PrecomputedSample::clear_has_shapeinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PrecomputedSample::clear_shapeinfo() {
  if (shapeinfo_ != NULL) shapeinfo_->::OptCAD::proto::ShapeInfo::Clear();
  clear_has_shapeinfo();
}
inline const ::OptCAD::proto::ShapeInfo& PrecomputedSample::shapeinfo() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedSample.shapeInfo)
  return shapeinfo_ != NULL ? *shapeinfo_
                         : *::OptCAD::proto::ShapeInfo::internal_default_instance();
}
inline ::OptCAD::proto::ShapeInfo* PrecomputedSample::mutable_shapeinfo() {
  set_has_shapeinfo();
  if (shapeinfo_ == NULL) {
    shapeinfo_ = new ::OptCAD::proto::ShapeInfo;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.PrecomputedSample.shapeInfo)
  return shapeinfo_;
}
inline ::OptCAD::proto::ShapeInfo* PrecomputedSample::release_shapeinfo() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.PrecomputedSample.shapeInfo)
  clear_has_shapeinfo();
  ::OptCAD::proto::ShapeInfo* temp = shapeinfo_;
  shapeinfo_ = NULL;
  return temp;
}
inline void PrecomputedSample::set_allocated_shapeinfo(::OptCAD::proto::ShapeInfo* shapeinfo) {
  delete shapeinfo_;
  shapeinfo_ = shapeinfo;
  if (shapeinfo) {
    set_has_shapeinfo();
  } else {
    clear_has_shapeinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.PrecomputedSample.shapeInfo)
}

// repeated .OptCAD.proto.BasisFunction basisFuntions = 4;
inline int PrecomputedSample::basisfuntions_size() const {
  return basisfuntions_.size();
}
inline void PrecomputedSample::clear_basisfuntions() {
  basisfuntions_.Clear();
}
inline const ::OptCAD::proto::BasisFunction& PrecomputedSample::basisfuntions(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedSample.basisFuntions)
  return basisfuntions_.Get(index);
}
inline ::OptCAD::proto::BasisFunction* PrecomputedSample::mutable_basisfuntions(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.PrecomputedSample.basisFuntions)
  return basisfuntions_.Mutable(index);
}
inline ::OptCAD::proto::BasisFunction* PrecomputedSample::add_basisfuntions() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.PrecomputedSample.basisFuntions)
  return basisfuntions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BasisFunction >*
PrecomputedSample::mutable_basisfuntions() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.PrecomputedSample.basisFuntions)
  return &basisfuntions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BasisFunction >&
PrecomputedSample::basisfuntions() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.PrecomputedSample.basisFuntions)
  return basisfuntions_;
}

inline const PrecomputedSample* PrecomputedSample::internal_default_instance() {
  return &PrecomputedSample_default_instance_.get();
}
// -------------------------------------------------------------------

// FunctionTestShapeInfo

// optional double val = 1;
inline bool FunctionTestShapeInfo::has_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionTestShapeInfo::set_has_val() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FunctionTestShapeInfo::clear_has_val() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FunctionTestShapeInfo::clear_val() {
  val_ = 0;
  clear_has_val();
}
inline double FunctionTestShapeInfo::val() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.FunctionTestShapeInfo.val)
  return val_;
}
inline void FunctionTestShapeInfo::set_val(double value) {
  set_has_val();
  val_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.FunctionTestShapeInfo.val)
}

inline const FunctionTestShapeInfo* FunctionTestShapeInfo::internal_default_instance() {
  return &FunctionTestShapeInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// Vector4i

// optional int32 x = 1;
inline bool Vector4i::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector4i::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector4i::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector4i::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 Vector4i::x() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Vector4i.x)
  return x_;
}
inline void Vector4i::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.Vector4i.x)
}

// optional int32 y = 2;
inline bool Vector4i::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector4i::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector4i::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector4i::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 Vector4i::y() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Vector4i.y)
  return y_;
}
inline void Vector4i::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.Vector4i.y)
}

// optional int32 z = 3;
inline bool Vector4i::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector4i::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector4i::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector4i::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline ::google::protobuf::int32 Vector4i::z() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Vector4i.z)
  return z_;
}
inline void Vector4i::set_z(::google::protobuf::int32 value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.Vector4i.z)
}

// optional int32 w = 4;
inline bool Vector4i::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vector4i::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vector4i::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vector4i::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline ::google::protobuf::int32 Vector4i::w() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Vector4i.w)
  return w_;
}
inline void Vector4i::set_w(::google::protobuf::int32 value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.Vector4i.w)
}

inline const Vector4i* Vector4i::internal_default_instance() {
  return &Vector4i_default_instance_.get();
}
// -------------------------------------------------------------------

// Vector3d

// optional double x = 1;
inline bool Vector3d::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3d::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3d::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3d::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Vector3d::x() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Vector3d.x)
  return x_;
}
inline void Vector3d::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.Vector3d.x)
}

// optional double y = 2;
inline bool Vector3d::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3d::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3d::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3d::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Vector3d::y() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Vector3d.y)
  return y_;
}
inline void Vector3d::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.Vector3d.y)
}

// optional double z = 3;
inline bool Vector3d::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3d::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3d::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3d::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Vector3d::z() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Vector3d.z)
  return z_;
}
inline void Vector3d::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.Vector3d.z)
}

inline const Vector3d* Vector3d::internal_default_instance() {
  return &Vector3d_default_instance_.get();
}
// -------------------------------------------------------------------

// BoundaryConditionValue

// optional .OptCAD.proto.Vector3d force = 1;
inline bool BoundaryConditionValue::has_force() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundaryConditionValue::set_has_force() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundaryConditionValue::clear_has_force() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundaryConditionValue::clear_force() {
  if (force_ != NULL) force_->::OptCAD::proto::Vector3d::Clear();
  clear_has_force();
}
inline const ::OptCAD::proto::Vector3d& BoundaryConditionValue::force() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BoundaryConditionValue.force)
  return force_ != NULL ? *force_
                         : *::OptCAD::proto::Vector3d::internal_default_instance();
}
inline ::OptCAD::proto::Vector3d* BoundaryConditionValue::mutable_force() {
  set_has_force();
  if (force_ == NULL) {
    force_ = new ::OptCAD::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.BoundaryConditionValue.force)
  return force_;
}
inline ::OptCAD::proto::Vector3d* BoundaryConditionValue::release_force() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.BoundaryConditionValue.force)
  clear_has_force();
  ::OptCAD::proto::Vector3d* temp = force_;
  force_ = NULL;
  return temp;
}
inline void BoundaryConditionValue::set_allocated_force(::OptCAD::proto::Vector3d* force) {
  delete force_;
  force_ = force;
  if (force) {
    set_has_force();
  } else {
    clear_has_force();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.BoundaryConditionValue.force)
}

// optional double heatValue = 2;
inline bool BoundaryConditionValue::has_heatvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundaryConditionValue::set_has_heatvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundaryConditionValue::clear_has_heatvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundaryConditionValue::clear_heatvalue() {
  heatvalue_ = 0;
  clear_has_heatvalue();
}
inline double BoundaryConditionValue::heatvalue() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BoundaryConditionValue.heatValue)
  return heatvalue_;
}
inline void BoundaryConditionValue::set_heatvalue(double value) {
  set_has_heatvalue();
  heatvalue_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.BoundaryConditionValue.heatValue)
}

// optional .OptCAD.proto.BoundaryType boundaryType = 3;
inline bool BoundaryConditionValue::has_boundarytype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BoundaryConditionValue::set_has_boundarytype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BoundaryConditionValue::clear_has_boundarytype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BoundaryConditionValue::clear_boundarytype() {
  boundarytype_ = 0;
  clear_has_boundarytype();
}
inline ::OptCAD::proto::BoundaryType BoundaryConditionValue::boundarytype() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BoundaryConditionValue.boundaryType)
  return static_cast< ::OptCAD::proto::BoundaryType >(boundarytype_);
}
inline void BoundaryConditionValue::set_boundarytype(::OptCAD::proto::BoundaryType value) {
  assert(::OptCAD::proto::BoundaryType_IsValid(value));
  set_has_boundarytype();
  boundarytype_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.BoundaryConditionValue.boundaryType)
}

inline const BoundaryConditionValue* BoundaryConditionValue::internal_default_instance() {
  return &BoundaryConditionValue_default_instance_.get();
}
// -------------------------------------------------------------------

// BoundaryCondition

// optional bool isFixed = 1;
inline bool BoundaryCondition::has_isfixed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BoundaryCondition::set_has_isfixed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BoundaryCondition::clear_has_isfixed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BoundaryCondition::clear_isfixed() {
  isfixed_ = false;
  clear_has_isfixed();
}
inline bool BoundaryCondition::isfixed() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BoundaryCondition.isFixed)
  return isfixed_;
}
inline void BoundaryCondition::set_isfixed(bool value) {
  set_has_isfixed();
  isfixed_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.BoundaryCondition.isFixed)
}

// optional .OptCAD.proto.Vector3d force = 2;
inline bool BoundaryCondition::has_force() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundaryCondition::set_has_force() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundaryCondition::clear_has_force() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundaryCondition::clear_force() {
  if (force_ != NULL) force_->::OptCAD::proto::Vector3d::Clear();
  clear_has_force();
}
inline const ::OptCAD::proto::Vector3d& BoundaryCondition::force() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BoundaryCondition.force)
  return force_ != NULL ? *force_
                         : *::OptCAD::proto::Vector3d::internal_default_instance();
}
inline ::OptCAD::proto::Vector3d* BoundaryCondition::mutable_force() {
  set_has_force();
  if (force_ == NULL) {
    force_ = new ::OptCAD::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.BoundaryCondition.force)
  return force_;
}
inline ::OptCAD::proto::Vector3d* BoundaryCondition::release_force() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.BoundaryCondition.force)
  clear_has_force();
  ::OptCAD::proto::Vector3d* temp = force_;
  force_ = NULL;
  return temp;
}
inline void BoundaryCondition::set_allocated_force(::OptCAD::proto::Vector3d* force) {
  delete force_;
  force_ = force;
  if (force) {
    set_has_force();
  } else {
    clear_has_force();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.BoundaryCondition.force)
}

// repeated int32 vertices = 3;
inline int BoundaryCondition::vertices_size() const {
  return vertices_.size();
}
inline void BoundaryCondition::clear_vertices() {
  vertices_.Clear();
}
inline ::google::protobuf::int32 BoundaryCondition::vertices(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BoundaryCondition.vertices)
  return vertices_.Get(index);
}
inline void BoundaryCondition::set_vertices(int index, ::google::protobuf::int32 value) {
  vertices_.Set(index, value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.BoundaryCondition.vertices)
}
inline void BoundaryCondition::add_vertices(::google::protobuf::int32 value) {
  vertices_.Add(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.BoundaryCondition.vertices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
BoundaryCondition::vertices() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.BoundaryCondition.vertices)
  return vertices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
BoundaryCondition::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.BoundaryCondition.vertices)
  return &vertices_;
}

// optional .OptCAD.proto.BoundaryConditionValue value = 4;
inline bool BoundaryCondition::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BoundaryCondition::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BoundaryCondition::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BoundaryCondition::clear_value() {
  if (value_ != NULL) value_->::OptCAD::proto::BoundaryConditionValue::Clear();
  clear_has_value();
}
inline const ::OptCAD::proto::BoundaryConditionValue& BoundaryCondition::value() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BoundaryCondition.value)
  return value_ != NULL ? *value_
                         : *::OptCAD::proto::BoundaryConditionValue::internal_default_instance();
}
inline ::OptCAD::proto::BoundaryConditionValue* BoundaryCondition::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::OptCAD::proto::BoundaryConditionValue;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.BoundaryCondition.value)
  return value_;
}
inline ::OptCAD::proto::BoundaryConditionValue* BoundaryCondition::release_value() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.BoundaryCondition.value)
  clear_has_value();
  ::OptCAD::proto::BoundaryConditionValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void BoundaryCondition::set_allocated_value(::OptCAD::proto::BoundaryConditionValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.BoundaryCondition.value)
}

inline const BoundaryCondition* BoundaryCondition::internal_default_instance() {
  return &BoundaryCondition_default_instance_.get();
}
// -------------------------------------------------------------------

// PrecomputedPhysics

// optional string name = 1;
inline bool PrecomputedPhysics::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrecomputedPhysics::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrecomputedPhysics::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrecomputedPhysics::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& PrecomputedPhysics::name() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedPhysics.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrecomputedPhysics::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.PrecomputedPhysics.name)
}
inline void PrecomputedPhysics::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OptCAD.proto.PrecomputedPhysics.name)
}
inline void PrecomputedPhysics::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OptCAD.proto.PrecomputedPhysics.name)
}
inline ::std::string* PrecomputedPhysics::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.PrecomputedPhysics.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrecomputedPhysics::release_name() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.PrecomputedPhysics.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrecomputedPhysics::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.PrecomputedPhysics.name)
}

// repeated double values = 2;
inline int PrecomputedPhysics::values_size() const {
  return values_.size();
}
inline void PrecomputedPhysics::clear_values() {
  values_.Clear();
}
inline double PrecomputedPhysics::values(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.PrecomputedPhysics.values)
  return values_.Get(index);
}
inline void PrecomputedPhysics::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.PrecomputedPhysics.values)
}
inline void PrecomputedPhysics::add_values(double value) {
  values_.Add(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.PrecomputedPhysics.values)
}
inline const ::google::protobuf::RepeatedField< double >&
PrecomputedPhysics::values() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.PrecomputedPhysics.values)
  return values_;
}
inline ::google::protobuf::RepeatedField< double >*
PrecomputedPhysics::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.PrecomputedPhysics.values)
  return &values_;
}

inline const PrecomputedPhysics* PrecomputedPhysics::internal_default_instance() {
  return &PrecomputedPhysics_default_instance_.get();
}
// -------------------------------------------------------------------

// ReferencePoint

// optional string id = 1;
inline bool ReferencePoint::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferencePoint::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferencePoint::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferencePoint::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& ReferencePoint::id() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.ReferencePoint.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReferencePoint::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.ReferencePoint.id)
}
inline void ReferencePoint::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OptCAD.proto.ReferencePoint.id)
}
inline void ReferencePoint::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OptCAD.proto.ReferencePoint.id)
}
inline ::std::string* ReferencePoint::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.ReferencePoint.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReferencePoint::release_id() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.ReferencePoint.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReferencePoint::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.ReferencePoint.id)
}

// optional .OptCAD.proto.Vector3d pos = 2;
inline bool ReferencePoint::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferencePoint::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferencePoint::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferencePoint::clear_pos() {
  if (pos_ != NULL) pos_->::OptCAD::proto::Vector3d::Clear();
  clear_has_pos();
}
inline const ::OptCAD::proto::Vector3d& ReferencePoint::pos() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.ReferencePoint.pos)
  return pos_ != NULL ? *pos_
                         : *::OptCAD::proto::Vector3d::internal_default_instance();
}
inline ::OptCAD::proto::Vector3d* ReferencePoint::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::OptCAD::proto::Vector3d;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.ReferencePoint.pos)
  return pos_;
}
inline ::OptCAD::proto::Vector3d* ReferencePoint::release_pos() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.ReferencePoint.pos)
  clear_has_pos();
  ::OptCAD::proto::Vector3d* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void ReferencePoint::set_allocated_pos(::OptCAD::proto::Vector3d* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    set_has_pos();
  } else {
    clear_has_pos();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.ReferencePoint.pos)
}

inline const ReferencePoint* ReferencePoint::internal_default_instance() {
  return &ReferencePoint_default_instance_.get();
}
// -------------------------------------------------------------------

// Link

// optional string first = 1;
inline bool Link::has_first() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Link::set_has_first() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Link::clear_has_first() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Link::clear_first() {
  first_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_first();
}
inline const ::std::string& Link::first() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Link.first)
  return first_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_first(const ::std::string& value) {
  set_has_first();
  first_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.Link.first)
}
inline void Link::set_first(const char* value) {
  set_has_first();
  first_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OptCAD.proto.Link.first)
}
inline void Link::set_first(const char* value, size_t size) {
  set_has_first();
  first_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OptCAD.proto.Link.first)
}
inline ::std::string* Link::mutable_first() {
  set_has_first();
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.Link.first)
  return first_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Link::release_first() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.Link.first)
  clear_has_first();
  return first_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_allocated_first(::std::string* first) {
  if (first != NULL) {
    set_has_first();
  } else {
    clear_has_first();
  }
  first_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), first);
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.Link.first)
}

// optional string second = 2;
inline bool Link::has_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Link::set_has_second() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Link::clear_has_second() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Link::clear_second() {
  second_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_second();
}
inline const ::std::string& Link::second() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Link.second)
  return second_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_second(const ::std::string& value) {
  set_has_second();
  second_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.Link.second)
}
inline void Link::set_second(const char* value) {
  set_has_second();
  second_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OptCAD.proto.Link.second)
}
inline void Link::set_second(const char* value, size_t size) {
  set_has_second();
  second_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OptCAD.proto.Link.second)
}
inline ::std::string* Link::mutable_second() {
  set_has_second();
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.Link.second)
  return second_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Link::release_second() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.Link.second)
  clear_has_second();
  return second_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Link::set_allocated_second(::std::string* second) {
  if (second != NULL) {
    set_has_second();
  } else {
    clear_has_second();
  }
  second_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), second);
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.Link.second)
}

// repeated .OptCAD.proto.Vector3d midPoints = 3;
inline int Link::midpoints_size() const {
  return midpoints_.size();
}
inline void Link::clear_midpoints() {
  midpoints_.Clear();
}
inline const ::OptCAD::proto::Vector3d& Link::midpoints(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.Link.midPoints)
  return midpoints_.Get(index);
}
inline ::OptCAD::proto::Vector3d* Link::mutable_midpoints(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.Link.midPoints)
  return midpoints_.Mutable(index);
}
inline ::OptCAD::proto::Vector3d* Link::add_midpoints() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.Link.midPoints)
  return midpoints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d >*
Link::mutable_midpoints() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.Link.midPoints)
  return &midpoints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d >&
Link::midpoints() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.Link.midPoints)
  return midpoints_;
}

inline const Link* Link::internal_default_instance() {
  return &Link_default_instance_.get();
}
// -------------------------------------------------------------------

// ControlLoop

// repeated string loop = 1;
inline int ControlLoop::loop_size() const {
  return loop_.size();
}
inline void ControlLoop::clear_loop() {
  loop_.Clear();
}
inline const ::std::string& ControlLoop::loop(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.ControlLoop.loop)
  return loop_.Get(index);
}
inline ::std::string* ControlLoop::mutable_loop(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.ControlLoop.loop)
  return loop_.Mutable(index);
}
inline void ControlLoop::set_loop(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:OptCAD.proto.ControlLoop.loop)
  loop_.Mutable(index)->assign(value);
}
inline void ControlLoop::set_loop(int index, const char* value) {
  loop_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:OptCAD.proto.ControlLoop.loop)
}
inline void ControlLoop::set_loop(int index, const char* value, size_t size) {
  loop_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:OptCAD.proto.ControlLoop.loop)
}
inline ::std::string* ControlLoop::add_loop() {
  // @@protoc_insertion_point(field_add_mutable:OptCAD.proto.ControlLoop.loop)
  return loop_.Add();
}
inline void ControlLoop::add_loop(const ::std::string& value) {
  loop_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.ControlLoop.loop)
}
inline void ControlLoop::add_loop(const char* value) {
  loop_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:OptCAD.proto.ControlLoop.loop)
}
inline void ControlLoop::add_loop(const char* value, size_t size) {
  loop_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:OptCAD.proto.ControlLoop.loop)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ControlLoop::loop() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.ControlLoop.loop)
  return loop_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ControlLoop::mutable_loop() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.ControlLoop.loop)
  return &loop_;
}

inline const ControlLoop* ControlLoop::internal_default_instance() {
  return &ControlLoop_default_instance_.get();
}
// -------------------------------------------------------------------

// BoundaryControl

// repeated .OptCAD.proto.ControlLoop controlLoops = 1;
inline int BoundaryControl::controlloops_size() const {
  return controlloops_.size();
}
inline void BoundaryControl::clear_controlloops() {
  controlloops_.Clear();
}
inline const ::OptCAD::proto::ControlLoop& BoundaryControl::controlloops(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BoundaryControl.controlLoops)
  return controlloops_.Get(index);
}
inline ::OptCAD::proto::ControlLoop* BoundaryControl::mutable_controlloops(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.BoundaryControl.controlLoops)
  return controlloops_.Mutable(index);
}
inline ::OptCAD::proto::ControlLoop* BoundaryControl::add_controlloops() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.BoundaryControl.controlLoops)
  return controlloops_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ControlLoop >*
BoundaryControl::mutable_controlloops() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.BoundaryControl.controlLoops)
  return &controlloops_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ControlLoop >&
BoundaryControl::controlloops() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.BoundaryControl.controlLoops)
  return controlloops_;
}

// optional .OptCAD.proto.BoundaryConditionValue value = 2;
inline bool BoundaryControl::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BoundaryControl::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BoundaryControl::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BoundaryControl::clear_value() {
  if (value_ != NULL) value_->::OptCAD::proto::BoundaryConditionValue::Clear();
  clear_has_value();
}
inline const ::OptCAD::proto::BoundaryConditionValue& BoundaryControl::value() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BoundaryControl.value)
  return value_ != NULL ? *value_
                         : *::OptCAD::proto::BoundaryConditionValue::internal_default_instance();
}
inline ::OptCAD::proto::BoundaryConditionValue* BoundaryControl::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::OptCAD::proto::BoundaryConditionValue;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.BoundaryControl.value)
  return value_;
}
inline ::OptCAD::proto::BoundaryConditionValue* BoundaryControl::release_value() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.BoundaryControl.value)
  clear_has_value();
  ::OptCAD::proto::BoundaryConditionValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline void BoundaryControl::set_allocated_value(::OptCAD::proto::BoundaryConditionValue* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.BoundaryControl.value)
}

inline const BoundaryControl* BoundaryControl::internal_default_instance() {
  return &BoundaryControl_default_instance_.get();
}
// -------------------------------------------------------------------

// ControlPoints

// repeated .OptCAD.proto.ReferencePoint point = 1;
inline int ControlPoints::point_size() const {
  return point_.size();
}
inline void ControlPoints::clear_point() {
  point_.Clear();
}
inline const ::OptCAD::proto::ReferencePoint& ControlPoints::point(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.ControlPoints.point)
  return point_.Get(index);
}
inline ::OptCAD::proto::ReferencePoint* ControlPoints::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.ControlPoints.point)
  return point_.Mutable(index);
}
inline ::OptCAD::proto::ReferencePoint* ControlPoints::add_point() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.ControlPoints.point)
  return point_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ReferencePoint >*
ControlPoints::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.ControlPoints.point)
  return &point_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::ReferencePoint >&
ControlPoints::point() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.ControlPoints.point)
  return point_;
}

// repeated .OptCAD.proto.Link links = 2;
inline int ControlPoints::links_size() const {
  return links_.size();
}
inline void ControlPoints::clear_links() {
  links_.Clear();
}
inline const ::OptCAD::proto::Link& ControlPoints::links(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.ControlPoints.links)
  return links_.Get(index);
}
inline ::OptCAD::proto::Link* ControlPoints::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.ControlPoints.links)
  return links_.Mutable(index);
}
inline ::OptCAD::proto::Link* ControlPoints::add_links() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.ControlPoints.links)
  return links_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Link >*
ControlPoints::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.ControlPoints.links)
  return &links_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Link >&
ControlPoints::links() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.ControlPoints.links)
  return links_;
}

// repeated .OptCAD.proto.BoundaryControl boundaryControls = 3;
inline int ControlPoints::boundarycontrols_size() const {
  return boundarycontrols_.size();
}
inline void ControlPoints::clear_boundarycontrols() {
  boundarycontrols_.Clear();
}
inline const ::OptCAD::proto::BoundaryControl& ControlPoints::boundarycontrols(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.ControlPoints.boundaryControls)
  return boundarycontrols_.Get(index);
}
inline ::OptCAD::proto::BoundaryControl* ControlPoints::mutable_boundarycontrols(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.ControlPoints.boundaryControls)
  return boundarycontrols_.Mutable(index);
}
inline ::OptCAD::proto::BoundaryControl* ControlPoints::add_boundarycontrols() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.ControlPoints.boundaryControls)
  return boundarycontrols_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryControl >*
ControlPoints::mutable_boundarycontrols() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.ControlPoints.boundaryControls)
  return &boundarycontrols_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryControl >&
ControlPoints::boundarycontrols() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.ControlPoints.boundaryControls)
  return boundarycontrols_;
}

inline const ControlPoints* ControlPoints::internal_default_instance() {
  return &ControlPoints_default_instance_.get();
}
// -------------------------------------------------------------------

// TetMesh

// repeated .OptCAD.proto.Vector3d vertices = 1;
inline int TetMesh::vertices_size() const {
  return vertices_.size();
}
inline void TetMesh::clear_vertices() {
  vertices_.Clear();
}
inline const ::OptCAD::proto::Vector3d& TetMesh::vertices(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.TetMesh.vertices)
  return vertices_.Get(index);
}
inline ::OptCAD::proto::Vector3d* TetMesh::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.TetMesh.vertices)
  return vertices_.Mutable(index);
}
inline ::OptCAD::proto::Vector3d* TetMesh::add_vertices() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.TetMesh.vertices)
  return vertices_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d >*
TetMesh::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.TetMesh.vertices)
  return &vertices_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector3d >&
TetMesh::vertices() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.TetMesh.vertices)
  return vertices_;
}

// repeated .OptCAD.proto.Vector4i tets = 2;
inline int TetMesh::tets_size() const {
  return tets_.size();
}
inline void TetMesh::clear_tets() {
  tets_.Clear();
}
inline const ::OptCAD::proto::Vector4i& TetMesh::tets(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.TetMesh.tets)
  return tets_.Get(index);
}
inline ::OptCAD::proto::Vector4i* TetMesh::mutable_tets(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.TetMesh.tets)
  return tets_.Mutable(index);
}
inline ::OptCAD::proto::Vector4i* TetMesh::add_tets() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.TetMesh.tets)
  return tets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector4i >*
TetMesh::mutable_tets() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.TetMesh.tets)
  return &tets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::Vector4i >&
TetMesh::tets() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.TetMesh.tets)
  return tets_;
}

// repeated .OptCAD.proto.BoundaryCondition boundaryConditions = 3;
inline int TetMesh::boundaryconditions_size() const {
  return boundaryconditions_.size();
}
inline void TetMesh::clear_boundaryconditions() {
  boundaryconditions_.Clear();
}
inline const ::OptCAD::proto::BoundaryCondition& TetMesh::boundaryconditions(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.TetMesh.boundaryConditions)
  return boundaryconditions_.Get(index);
}
inline ::OptCAD::proto::BoundaryCondition* TetMesh::mutable_boundaryconditions(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.TetMesh.boundaryConditions)
  return boundaryconditions_.Mutable(index);
}
inline ::OptCAD::proto::BoundaryCondition* TetMesh::add_boundaryconditions() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.TetMesh.boundaryConditions)
  return boundaryconditions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryCondition >*
TetMesh::mutable_boundaryconditions() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.TetMesh.boundaryConditions)
  return &boundaryconditions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::BoundaryCondition >&
TetMesh::boundaryconditions() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.TetMesh.boundaryConditions)
  return boundaryconditions_;
}

// repeated .OptCAD.proto.PrecomputedPhysics precomputedPhysics = 4;
inline int TetMesh::precomputedphysics_size() const {
  return precomputedphysics_.size();
}
inline void TetMesh::clear_precomputedphysics() {
  precomputedphysics_.Clear();
}
inline const ::OptCAD::proto::PrecomputedPhysics& TetMesh::precomputedphysics(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.TetMesh.precomputedPhysics)
  return precomputedphysics_.Get(index);
}
inline ::OptCAD::proto::PrecomputedPhysics* TetMesh::mutable_precomputedphysics(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.TetMesh.precomputedPhysics)
  return precomputedphysics_.Mutable(index);
}
inline ::OptCAD::proto::PrecomputedPhysics* TetMesh::add_precomputedphysics() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.TetMesh.precomputedPhysics)
  return precomputedphysics_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedPhysics >*
TetMesh::mutable_precomputedphysics() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.TetMesh.precomputedPhysics)
  return &precomputedphysics_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::PrecomputedPhysics >&
TetMesh::precomputedphysics() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.TetMesh.precomputedPhysics)
  return precomputedphysics_;
}

// optional string filename = 5;
inline bool TetMesh::has_filename() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TetMesh::set_has_filename() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TetMesh::clear_has_filename() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TetMesh::clear_filename() {
  filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filename();
}
inline const ::std::string& TetMesh::filename() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.TetMesh.filename)
  return filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TetMesh::set_filename(const ::std::string& value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.TetMesh.filename)
}
inline void TetMesh::set_filename(const char* value) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:OptCAD.proto.TetMesh.filename)
}
inline void TetMesh::set_filename(const char* value, size_t size) {
  set_has_filename();
  filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:OptCAD.proto.TetMesh.filename)
}
inline ::std::string* TetMesh::mutable_filename() {
  set_has_filename();
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.TetMesh.filename)
  return filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TetMesh::release_filename() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.TetMesh.filename)
  clear_has_filename();
  return filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TetMesh::set_allocated_filename(::std::string* filename) {
  if (filename != NULL) {
    set_has_filename();
  } else {
    clear_has_filename();
  }
  filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.TetMesh.filename)
}

// optional .OptCAD.proto.ControlPoints controlPoints = 6;
inline bool TetMesh::has_controlpoints() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TetMesh::set_has_controlpoints() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TetMesh::clear_has_controlpoints() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TetMesh::clear_controlpoints() {
  if (controlpoints_ != NULL) controlpoints_->::OptCAD::proto::ControlPoints::Clear();
  clear_has_controlpoints();
}
inline const ::OptCAD::proto::ControlPoints& TetMesh::controlpoints() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.TetMesh.controlPoints)
  return controlpoints_ != NULL ? *controlpoints_
                         : *::OptCAD::proto::ControlPoints::internal_default_instance();
}
inline ::OptCAD::proto::ControlPoints* TetMesh::mutable_controlpoints() {
  set_has_controlpoints();
  if (controlpoints_ == NULL) {
    controlpoints_ = new ::OptCAD::proto::ControlPoints;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.TetMesh.controlPoints)
  return controlpoints_;
}
inline ::OptCAD::proto::ControlPoints* TetMesh::release_controlpoints() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.TetMesh.controlPoints)
  clear_has_controlpoints();
  ::OptCAD::proto::ControlPoints* temp = controlpoints_;
  controlpoints_ = NULL;
  return temp;
}
inline void TetMesh::set_allocated_controlpoints(::OptCAD::proto::ControlPoints* controlpoints) {
  delete controlpoints_;
  controlpoints_ = controlpoints;
  if (controlpoints) {
    set_has_controlpoints();
  } else {
    clear_has_controlpoints();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.TetMesh.controlPoints)
}

inline const TetMesh* TetMesh::internal_default_instance() {
  return &TetMesh_default_instance_.get();
}
// -------------------------------------------------------------------

// ShapeInfo

// optional .OptCAD.proto.FunctionTestShapeInfo functionShapeInfo = 1;
inline bool ShapeInfo::has_functionshapeinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShapeInfo::set_has_functionshapeinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShapeInfo::clear_has_functionshapeinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShapeInfo::clear_functionshapeinfo() {
  if (functionshapeinfo_ != NULL) functionshapeinfo_->::OptCAD::proto::FunctionTestShapeInfo::Clear();
  clear_has_functionshapeinfo();
}
inline const ::OptCAD::proto::FunctionTestShapeInfo& ShapeInfo::functionshapeinfo() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.ShapeInfo.functionShapeInfo)
  return functionshapeinfo_ != NULL ? *functionshapeinfo_
                         : *::OptCAD::proto::FunctionTestShapeInfo::internal_default_instance();
}
inline ::OptCAD::proto::FunctionTestShapeInfo* ShapeInfo::mutable_functionshapeinfo() {
  set_has_functionshapeinfo();
  if (functionshapeinfo_ == NULL) {
    functionshapeinfo_ = new ::OptCAD::proto::FunctionTestShapeInfo;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.ShapeInfo.functionShapeInfo)
  return functionshapeinfo_;
}
inline ::OptCAD::proto::FunctionTestShapeInfo* ShapeInfo::release_functionshapeinfo() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.ShapeInfo.functionShapeInfo)
  clear_has_functionshapeinfo();
  ::OptCAD::proto::FunctionTestShapeInfo* temp = functionshapeinfo_;
  functionshapeinfo_ = NULL;
  return temp;
}
inline void ShapeInfo::set_allocated_functionshapeinfo(::OptCAD::proto::FunctionTestShapeInfo* functionshapeinfo) {
  delete functionshapeinfo_;
  functionshapeinfo_ = functionshapeinfo;
  if (functionshapeinfo) {
    set_has_functionshapeinfo();
  } else {
    clear_has_functionshapeinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.ShapeInfo.functionShapeInfo)
}

// optional .OptCAD.proto.TetMesh tetMesh = 2;
inline bool ShapeInfo::has_tetmesh() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShapeInfo::set_has_tetmesh() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShapeInfo::clear_has_tetmesh() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShapeInfo::clear_tetmesh() {
  if (tetmesh_ != NULL) tetmesh_->::OptCAD::proto::TetMesh::Clear();
  clear_has_tetmesh();
}
inline const ::OptCAD::proto::TetMesh& ShapeInfo::tetmesh() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.ShapeInfo.tetMesh)
  return tetmesh_ != NULL ? *tetmesh_
                         : *::OptCAD::proto::TetMesh::internal_default_instance();
}
inline ::OptCAD::proto::TetMesh* ShapeInfo::mutable_tetmesh() {
  set_has_tetmesh();
  if (tetmesh_ == NULL) {
    tetmesh_ = new ::OptCAD::proto::TetMesh;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.ShapeInfo.tetMesh)
  return tetmesh_;
}
inline ::OptCAD::proto::TetMesh* ShapeInfo::release_tetmesh() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.ShapeInfo.tetMesh)
  clear_has_tetmesh();
  ::OptCAD::proto::TetMesh* temp = tetmesh_;
  tetmesh_ = NULL;
  return temp;
}
inline void ShapeInfo::set_allocated_tetmesh(::OptCAD::proto::TetMesh* tetmesh) {
  delete tetmesh_;
  tetmesh_ = tetmesh;
  if (tetmesh) {
    set_has_tetmesh();
  } else {
    clear_has_tetmesh();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.ShapeInfo.tetMesh)
}

inline const ShapeInfo* ShapeInfo::internal_default_instance() {
  return &ShapeInfo_default_instance_.get();
}
// -------------------------------------------------------------------

// BasisFunction

// optional .OptCAD.proto.LinearBSpline linearBspline = 1;
inline bool BasisFunction::has_linearbspline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BasisFunction::set_has_linearbspline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BasisFunction::clear_has_linearbspline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BasisFunction::clear_linearbspline() {
  if (linearbspline_ != NULL) linearbspline_->::OptCAD::proto::LinearBSpline::Clear();
  clear_has_linearbspline();
}
inline const ::OptCAD::proto::LinearBSpline& BasisFunction::linearbspline() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BasisFunction.linearBspline)
  return linearbspline_ != NULL ? *linearbspline_
                         : *::OptCAD::proto::LinearBSpline::internal_default_instance();
}
inline ::OptCAD::proto::LinearBSpline* BasisFunction::mutable_linearbspline() {
  set_has_linearbspline();
  if (linearbspline_ == NULL) {
    linearbspline_ = new ::OptCAD::proto::LinearBSpline;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.BasisFunction.linearBspline)
  return linearbspline_;
}
inline ::OptCAD::proto::LinearBSpline* BasisFunction::release_linearbspline() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.BasisFunction.linearBspline)
  clear_has_linearbspline();
  ::OptCAD::proto::LinearBSpline* temp = linearbspline_;
  linearbspline_ = NULL;
  return temp;
}
inline void BasisFunction::set_allocated_linearbspline(::OptCAD::proto::LinearBSpline* linearbspline) {
  delete linearbspline_;
  linearbspline_ = linearbspline;
  if (linearbspline) {
    set_has_linearbspline();
  } else {
    clear_has_linearbspline();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.BasisFunction.linearBspline)
}

// optional .OptCAD.proto.CubicBSpline cubicBspline = 2;
inline bool BasisFunction::has_cubicbspline() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BasisFunction::set_has_cubicbspline() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BasisFunction::clear_has_cubicbspline() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BasisFunction::clear_cubicbspline() {
  if (cubicbspline_ != NULL) cubicbspline_->::OptCAD::proto::CubicBSpline::Clear();
  clear_has_cubicbspline();
}
inline const ::OptCAD::proto::CubicBSpline& BasisFunction::cubicbspline() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.BasisFunction.cubicBspline)
  return cubicbspline_ != NULL ? *cubicbspline_
                         : *::OptCAD::proto::CubicBSpline::internal_default_instance();
}
inline ::OptCAD::proto::CubicBSpline* BasisFunction::mutable_cubicbspline() {
  set_has_cubicbspline();
  if (cubicbspline_ == NULL) {
    cubicbspline_ = new ::OptCAD::proto::CubicBSpline;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.BasisFunction.cubicBspline)
  return cubicbspline_;
}
inline ::OptCAD::proto::CubicBSpline* BasisFunction::release_cubicbspline() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.BasisFunction.cubicBspline)
  clear_has_cubicbspline();
  ::OptCAD::proto::CubicBSpline* temp = cubicbspline_;
  cubicbspline_ = NULL;
  return temp;
}
inline void BasisFunction::set_allocated_cubicbspline(::OptCAD::proto::CubicBSpline* cubicbspline) {
  delete cubicbspline_;
  cubicbspline_ = cubicbspline;
  if (cubicbspline) {
    set_has_cubicbspline();
  } else {
    clear_has_cubicbspline();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.BasisFunction.cubicBspline)
}

inline const BasisFunction* BasisFunction::internal_default_instance() {
  return &BasisFunction_default_instance_.get();
}
// -------------------------------------------------------------------

// LinearBSpline

// repeated double center = 1;
inline int LinearBSpline::center_size() const {
  return center_.size();
}
inline void LinearBSpline::clear_center() {
  center_.Clear();
}
inline double LinearBSpline::center(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.LinearBSpline.center)
  return center_.Get(index);
}
inline void LinearBSpline::set_center(int index, double value) {
  center_.Set(index, value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.LinearBSpline.center)
}
inline void LinearBSpline::add_center(double value) {
  center_.Add(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.LinearBSpline.center)
}
inline const ::google::protobuf::RepeatedField< double >&
LinearBSpline::center() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.LinearBSpline.center)
  return center_;
}
inline ::google::protobuf::RepeatedField< double >*
LinearBSpline::mutable_center() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.LinearBSpline.center)
  return &center_;
}

// repeated double support = 2;
inline int LinearBSpline::support_size() const {
  return support_.size();
}
inline void LinearBSpline::clear_support() {
  support_.Clear();
}
inline double LinearBSpline::support(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.LinearBSpline.support)
  return support_.Get(index);
}
inline void LinearBSpline::set_support(int index, double value) {
  support_.Set(index, value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.LinearBSpline.support)
}
inline void LinearBSpline::add_support(double value) {
  support_.Add(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.LinearBSpline.support)
}
inline const ::google::protobuf::RepeatedField< double >&
LinearBSpline::support() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.LinearBSpline.support)
  return support_;
}
inline ::google::protobuf::RepeatedField< double >*
LinearBSpline::mutable_support() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.LinearBSpline.support)
  return &support_;
}

// optional double weight = 3;
inline bool LinearBSpline::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinearBSpline::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinearBSpline::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinearBSpline::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double LinearBSpline::weight() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.LinearBSpline.weight)
  return weight_;
}
inline void LinearBSpline::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.LinearBSpline.weight)
}

inline const LinearBSpline* LinearBSpline::internal_default_instance() {
  return &LinearBSpline_default_instance_.get();
}
// -------------------------------------------------------------------

// CubicBSpline

// repeated double center = 1;
inline int CubicBSpline::center_size() const {
  return center_.size();
}
inline void CubicBSpline::clear_center() {
  center_.Clear();
}
inline double CubicBSpline::center(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.CubicBSpline.center)
  return center_.Get(index);
}
inline void CubicBSpline::set_center(int index, double value) {
  center_.Set(index, value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.CubicBSpline.center)
}
inline void CubicBSpline::add_center(double value) {
  center_.Add(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.CubicBSpline.center)
}
inline const ::google::protobuf::RepeatedField< double >&
CubicBSpline::center() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.CubicBSpline.center)
  return center_;
}
inline ::google::protobuf::RepeatedField< double >*
CubicBSpline::mutable_center() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.CubicBSpline.center)
  return &center_;
}

// repeated double support = 2;
inline int CubicBSpline::support_size() const {
  return support_.size();
}
inline void CubicBSpline::clear_support() {
  support_.Clear();
}
inline double CubicBSpline::support(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.CubicBSpline.support)
  return support_.Get(index);
}
inline void CubicBSpline::set_support(int index, double value) {
  support_.Set(index, value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.CubicBSpline.support)
}
inline void CubicBSpline::add_support(double value) {
  support_.Add(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.CubicBSpline.support)
}
inline const ::google::protobuf::RepeatedField< double >&
CubicBSpline::support() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.CubicBSpline.support)
  return support_;
}
inline ::google::protobuf::RepeatedField< double >*
CubicBSpline::mutable_support() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.CubicBSpline.support)
  return &support_;
}

// optional double weight = 3;
inline bool CubicBSpline::has_weight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CubicBSpline::set_has_weight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CubicBSpline::clear_has_weight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CubicBSpline::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline double CubicBSpline::weight() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.CubicBSpline.weight)
  return weight_;
}
inline void CubicBSpline::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.CubicBSpline.weight)
}

inline const CubicBSpline* CubicBSpline::internal_default_instance() {
  return &CubicBSpline_default_instance_.get();
}
// -------------------------------------------------------------------

// AdaptiveGridCell

// repeated double ranges = 1;
inline int AdaptiveGridCell::ranges_size() const {
  return ranges_.size();
}
inline void AdaptiveGridCell::clear_ranges() {
  ranges_.Clear();
}
inline double AdaptiveGridCell::ranges(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.AdaptiveGridCell.ranges)
  return ranges_.Get(index);
}
inline void AdaptiveGridCell::set_ranges(int index, double value) {
  ranges_.Set(index, value);
  // @@protoc_insertion_point(field_set:OptCAD.proto.AdaptiveGridCell.ranges)
}
inline void AdaptiveGridCell::add_ranges(double value) {
  ranges_.Add(value);
  // @@protoc_insertion_point(field_add:OptCAD.proto.AdaptiveGridCell.ranges)
}
inline const ::google::protobuf::RepeatedField< double >&
AdaptiveGridCell::ranges() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.AdaptiveGridCell.ranges)
  return ranges_;
}
inline ::google::protobuf::RepeatedField< double >*
AdaptiveGridCell::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.AdaptiveGridCell.ranges)
  return &ranges_;
}

// optional .OptCAD.proto.AdaptiveGridLeaf leaf = 2;
inline bool AdaptiveGridCell::has_leaf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdaptiveGridCell::set_has_leaf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdaptiveGridCell::clear_has_leaf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdaptiveGridCell::clear_leaf() {
  if (leaf_ != NULL) leaf_->::OptCAD::proto::AdaptiveGridLeaf::Clear();
  clear_has_leaf();
}
inline const ::OptCAD::proto::AdaptiveGridLeaf& AdaptiveGridCell::leaf() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.AdaptiveGridCell.leaf)
  return leaf_ != NULL ? *leaf_
                         : *::OptCAD::proto::AdaptiveGridLeaf::internal_default_instance();
}
inline ::OptCAD::proto::AdaptiveGridLeaf* AdaptiveGridCell::mutable_leaf() {
  set_has_leaf();
  if (leaf_ == NULL) {
    leaf_ = new ::OptCAD::proto::AdaptiveGridLeaf;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.AdaptiveGridCell.leaf)
  return leaf_;
}
inline ::OptCAD::proto::AdaptiveGridLeaf* AdaptiveGridCell::release_leaf() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.AdaptiveGridCell.leaf)
  clear_has_leaf();
  ::OptCAD::proto::AdaptiveGridLeaf* temp = leaf_;
  leaf_ = NULL;
  return temp;
}
inline void AdaptiveGridCell::set_allocated_leaf(::OptCAD::proto::AdaptiveGridLeaf* leaf) {
  delete leaf_;
  leaf_ = leaf;
  if (leaf) {
    set_has_leaf();
  } else {
    clear_has_leaf();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.AdaptiveGridCell.leaf)
}

// optional .OptCAD.proto.AdaptiveGridInterNode interNode = 3;
inline bool AdaptiveGridCell::has_internode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdaptiveGridCell::set_has_internode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdaptiveGridCell::clear_has_internode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdaptiveGridCell::clear_internode() {
  if (internode_ != NULL) internode_->::OptCAD::proto::AdaptiveGridInterNode::Clear();
  clear_has_internode();
}
inline const ::OptCAD::proto::AdaptiveGridInterNode& AdaptiveGridCell::internode() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.AdaptiveGridCell.interNode)
  return internode_ != NULL ? *internode_
                         : *::OptCAD::proto::AdaptiveGridInterNode::internal_default_instance();
}
inline ::OptCAD::proto::AdaptiveGridInterNode* AdaptiveGridCell::mutable_internode() {
  set_has_internode();
  if (internode_ == NULL) {
    internode_ = new ::OptCAD::proto::AdaptiveGridInterNode;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.AdaptiveGridCell.interNode)
  return internode_;
}
inline ::OptCAD::proto::AdaptiveGridInterNode* AdaptiveGridCell::release_internode() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.AdaptiveGridCell.interNode)
  clear_has_internode();
  ::OptCAD::proto::AdaptiveGridInterNode* temp = internode_;
  internode_ = NULL;
  return temp;
}
inline void AdaptiveGridCell::set_allocated_internode(::OptCAD::proto::AdaptiveGridInterNode* internode) {
  delete internode_;
  internode_ = internode;
  if (internode) {
    set_has_internode();
  } else {
    clear_has_internode();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.AdaptiveGridCell.interNode)
}

inline const AdaptiveGridCell* AdaptiveGridCell::internal_default_instance() {
  return &AdaptiveGridCell_default_instance_.get();
}
// -------------------------------------------------------------------

// AdaptiveGridLeaf

// optional .OptCAD.proto.ShapeInfo centerShapeInfo = 1;
inline bool AdaptiveGridLeaf::has_centershapeinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdaptiveGridLeaf::set_has_centershapeinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdaptiveGridLeaf::clear_has_centershapeinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdaptiveGridLeaf::clear_centershapeinfo() {
  if (centershapeinfo_ != NULL) centershapeinfo_->::OptCAD::proto::ShapeInfo::Clear();
  clear_has_centershapeinfo();
}
inline const ::OptCAD::proto::ShapeInfo& AdaptiveGridLeaf::centershapeinfo() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.AdaptiveGridLeaf.centerShapeInfo)
  return centershapeinfo_ != NULL ? *centershapeinfo_
                         : *::OptCAD::proto::ShapeInfo::internal_default_instance();
}
inline ::OptCAD::proto::ShapeInfo* AdaptiveGridLeaf::mutable_centershapeinfo() {
  set_has_centershapeinfo();
  if (centershapeinfo_ == NULL) {
    centershapeinfo_ = new ::OptCAD::proto::ShapeInfo;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.AdaptiveGridLeaf.centerShapeInfo)
  return centershapeinfo_;
}
inline ::OptCAD::proto::ShapeInfo* AdaptiveGridLeaf::release_centershapeinfo() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.AdaptiveGridLeaf.centerShapeInfo)
  clear_has_centershapeinfo();
  ::OptCAD::proto::ShapeInfo* temp = centershapeinfo_;
  centershapeinfo_ = NULL;
  return temp;
}
inline void AdaptiveGridLeaf::set_allocated_centershapeinfo(::OptCAD::proto::ShapeInfo* centershapeinfo) {
  delete centershapeinfo_;
  centershapeinfo_ = centershapeinfo;
  if (centershapeinfo) {
    set_has_centershapeinfo();
  } else {
    clear_has_centershapeinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.AdaptiveGridLeaf.centerShapeInfo)
}

// repeated .OptCAD.proto.HomeomorphicSample homeomorphicSamples = 2;
inline int AdaptiveGridLeaf::homeomorphicsamples_size() const {
  return homeomorphicsamples_.size();
}
inline void AdaptiveGridLeaf::clear_homeomorphicsamples() {
  homeomorphicsamples_.Clear();
}
inline const ::OptCAD::proto::HomeomorphicSample& AdaptiveGridLeaf::homeomorphicsamples(int index) const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.AdaptiveGridLeaf.homeomorphicSamples)
  return homeomorphicsamples_.Get(index);
}
inline ::OptCAD::proto::HomeomorphicSample* AdaptiveGridLeaf::mutable_homeomorphicsamples(int index) {
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.AdaptiveGridLeaf.homeomorphicSamples)
  return homeomorphicsamples_.Mutable(index);
}
inline ::OptCAD::proto::HomeomorphicSample* AdaptiveGridLeaf::add_homeomorphicsamples() {
  // @@protoc_insertion_point(field_add:OptCAD.proto.AdaptiveGridLeaf.homeomorphicSamples)
  return homeomorphicsamples_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::HomeomorphicSample >*
AdaptiveGridLeaf::mutable_homeomorphicsamples() {
  // @@protoc_insertion_point(field_mutable_list:OptCAD.proto.AdaptiveGridLeaf.homeomorphicSamples)
  return &homeomorphicsamples_;
}
inline const ::google::protobuf::RepeatedPtrField< ::OptCAD::proto::HomeomorphicSample >&
AdaptiveGridLeaf::homeomorphicsamples() const {
  // @@protoc_insertion_point(field_list:OptCAD.proto.AdaptiveGridLeaf.homeomorphicSamples)
  return homeomorphicsamples_;
}

inline const AdaptiveGridLeaf* AdaptiveGridLeaf::internal_default_instance() {
  return &AdaptiveGridLeaf_default_instance_.get();
}
// -------------------------------------------------------------------

// HomeomorphicSample

// optional int32 precomputedSampleID = 1;
inline bool HomeomorphicSample::has_precomputedsampleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HomeomorphicSample::set_has_precomputedsampleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HomeomorphicSample::clear_has_precomputedsampleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HomeomorphicSample::clear_precomputedsampleid() {
  precomputedsampleid_ = 0;
  clear_has_precomputedsampleid();
}
inline ::google::protobuf::int32 HomeomorphicSample::precomputedsampleid() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.HomeomorphicSample.precomputedSampleID)
  return precomputedsampleid_;
}
inline void HomeomorphicSample::set_precomputedsampleid(::google::protobuf::int32 value) {
  set_has_precomputedsampleid();
  precomputedsampleid_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.HomeomorphicSample.precomputedSampleID)
}

// optional .OptCAD.proto.ShapeInfo shapeInfo = 2;
inline bool HomeomorphicSample::has_shapeinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HomeomorphicSample::set_has_shapeinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HomeomorphicSample::clear_has_shapeinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HomeomorphicSample::clear_shapeinfo() {
  if (shapeinfo_ != NULL) shapeinfo_->::OptCAD::proto::ShapeInfo::Clear();
  clear_has_shapeinfo();
}
inline const ::OptCAD::proto::ShapeInfo& HomeomorphicSample::shapeinfo() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.HomeomorphicSample.shapeInfo)
  return shapeinfo_ != NULL ? *shapeinfo_
                         : *::OptCAD::proto::ShapeInfo::internal_default_instance();
}
inline ::OptCAD::proto::ShapeInfo* HomeomorphicSample::mutable_shapeinfo() {
  set_has_shapeinfo();
  if (shapeinfo_ == NULL) {
    shapeinfo_ = new ::OptCAD::proto::ShapeInfo;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.HomeomorphicSample.shapeInfo)
  return shapeinfo_;
}
inline ::OptCAD::proto::ShapeInfo* HomeomorphicSample::release_shapeinfo() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.HomeomorphicSample.shapeInfo)
  clear_has_shapeinfo();
  ::OptCAD::proto::ShapeInfo* temp = shapeinfo_;
  shapeinfo_ = NULL;
  return temp;
}
inline void HomeomorphicSample::set_allocated_shapeinfo(::OptCAD::proto::ShapeInfo* shapeinfo) {
  delete shapeinfo_;
  shapeinfo_ = shapeinfo;
  if (shapeinfo) {
    set_has_shapeinfo();
  } else {
    clear_has_shapeinfo();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.HomeomorphicSample.shapeInfo)
}

inline const HomeomorphicSample* HomeomorphicSample::internal_default_instance() {
  return &HomeomorphicSample_default_instance_.get();
}
// -------------------------------------------------------------------

// AdaptiveGridInterNode

// optional .OptCAD.proto.AdaptiveGridCell child1 = 1;
inline bool AdaptiveGridInterNode::has_child1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdaptiveGridInterNode::set_has_child1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdaptiveGridInterNode::clear_has_child1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdaptiveGridInterNode::clear_child1() {
  if (child1_ != NULL) child1_->::OptCAD::proto::AdaptiveGridCell::Clear();
  clear_has_child1();
}
inline const ::OptCAD::proto::AdaptiveGridCell& AdaptiveGridInterNode::child1() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.AdaptiveGridInterNode.child1)
  return child1_ != NULL ? *child1_
                         : *::OptCAD::proto::AdaptiveGridCell::internal_default_instance();
}
inline ::OptCAD::proto::AdaptiveGridCell* AdaptiveGridInterNode::mutable_child1() {
  set_has_child1();
  if (child1_ == NULL) {
    child1_ = new ::OptCAD::proto::AdaptiveGridCell;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.AdaptiveGridInterNode.child1)
  return child1_;
}
inline ::OptCAD::proto::AdaptiveGridCell* AdaptiveGridInterNode::release_child1() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.AdaptiveGridInterNode.child1)
  clear_has_child1();
  ::OptCAD::proto::AdaptiveGridCell* temp = child1_;
  child1_ = NULL;
  return temp;
}
inline void AdaptiveGridInterNode::set_allocated_child1(::OptCAD::proto::AdaptiveGridCell* child1) {
  delete child1_;
  child1_ = child1;
  if (child1) {
    set_has_child1();
  } else {
    clear_has_child1();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.AdaptiveGridInterNode.child1)
}

// optional .OptCAD.proto.AdaptiveGridCell child2 = 2;
inline bool AdaptiveGridInterNode::has_child2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdaptiveGridInterNode::set_has_child2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdaptiveGridInterNode::clear_has_child2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdaptiveGridInterNode::clear_child2() {
  if (child2_ != NULL) child2_->::OptCAD::proto::AdaptiveGridCell::Clear();
  clear_has_child2();
}
inline const ::OptCAD::proto::AdaptiveGridCell& AdaptiveGridInterNode::child2() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.AdaptiveGridInterNode.child2)
  return child2_ != NULL ? *child2_
                         : *::OptCAD::proto::AdaptiveGridCell::internal_default_instance();
}
inline ::OptCAD::proto::AdaptiveGridCell* AdaptiveGridInterNode::mutable_child2() {
  set_has_child2();
  if (child2_ == NULL) {
    child2_ = new ::OptCAD::proto::AdaptiveGridCell;
  }
  // @@protoc_insertion_point(field_mutable:OptCAD.proto.AdaptiveGridInterNode.child2)
  return child2_;
}
inline ::OptCAD::proto::AdaptiveGridCell* AdaptiveGridInterNode::release_child2() {
  // @@protoc_insertion_point(field_release:OptCAD.proto.AdaptiveGridInterNode.child2)
  clear_has_child2();
  ::OptCAD::proto::AdaptiveGridCell* temp = child2_;
  child2_ = NULL;
  return temp;
}
inline void AdaptiveGridInterNode::set_allocated_child2(::OptCAD::proto::AdaptiveGridCell* child2) {
  delete child2_;
  child2_ = child2;
  if (child2) {
    set_has_child2();
  } else {
    clear_has_child2();
  }
  // @@protoc_insertion_point(field_set_allocated:OptCAD.proto.AdaptiveGridInterNode.child2)
}

// optional int32 splidDirection = 3;
inline bool AdaptiveGridInterNode::has_spliddirection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdaptiveGridInterNode::set_has_spliddirection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdaptiveGridInterNode::clear_has_spliddirection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdaptiveGridInterNode::clear_spliddirection() {
  spliddirection_ = 0;
  clear_has_spliddirection();
}
inline ::google::protobuf::int32 AdaptiveGridInterNode::spliddirection() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.AdaptiveGridInterNode.splidDirection)
  return spliddirection_;
}
inline void AdaptiveGridInterNode::set_spliddirection(::google::protobuf::int32 value) {
  set_has_spliddirection();
  spliddirection_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.AdaptiveGridInterNode.splidDirection)
}

// optional double splitVal = 4;
inline bool AdaptiveGridInterNode::has_splitval() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdaptiveGridInterNode::set_has_splitval() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdaptiveGridInterNode::clear_has_splitval() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdaptiveGridInterNode::clear_splitval() {
  splitval_ = 0;
  clear_has_splitval();
}
inline double AdaptiveGridInterNode::splitval() const {
  // @@protoc_insertion_point(field_get:OptCAD.proto.AdaptiveGridInterNode.splitVal)
  return splitval_;
}
inline void AdaptiveGridInterNode::set_splitval(double value) {
  set_has_splitval();
  splitval_ = value;
  // @@protoc_insertion_point(field_set:OptCAD.proto.AdaptiveGridInterNode.splitVal)
}

inline const AdaptiveGridInterNode* AdaptiveGridInterNode::internal_default_instance() {
  return &AdaptiveGridInterNode_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace OptCAD

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::OptCAD::proto::BoundaryType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OptCAD::proto::BoundaryType>() {
  return ::OptCAD::proto::BoundaryType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PrecomputedParametricShape_2eproto__INCLUDED
